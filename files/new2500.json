{
  "name": "field.api.php.new",
  "timestamp": "2012-11-02T16:05:51Z",
  "source": "<?php\n\n/**\n * @addtogroup hooks\n * @{\n */\n\n/**\n * Exposes \"pseudo-field\" components on fieldable entities.\n *\n * Field UI's \"Manage fields\" and \"Manage display\" pages let users re-order\n * fields, but also non-field components. For nodes, these include the title,\n * poll choices, and other elements exposed by modules through hook_form() or\n * hook_form_alter().\n *\n * Fieldable entities or modules that want to have their components supported\n * should expose them using this hook. The user-defined settings (weight,\n * visible) are automatically applied on rendered forms and displayed\n * entities in a #pre_render callback added by field_attach_form() and\n * field_attach_view().\n *\n * @see _field_extra_fields_pre_render()\n * @see hook_field_extra_fields_alter()\n *\n * @return\n *   A nested array of 'pseudo-field' components. Each list is nested within\n *   the following keys: entity type, bundle name, context (either 'form' or\n *   'display'). The keys are the name of the elements as appearing in the\n *   renderable array (either the entity form or the displayed entity). The\n *   value is an associative array:\n *   - label: The human readable name of the component.\n *   - description: A short description of the component contents.\n *   - weight: The default weight of the element.\n */\nfunction hook_field_extra_fields() {\n  $extra['node']['poll'] = array(\n    'form' => array(\n      'choice_wrapper' => array(\n        'label' => t('Poll choices'),\n        'description' => t('Poll choices'),\n        'weight' => -4,\n      ),\n      'settings' => array(\n        'label' => t('Poll settings'),\n        'description' => t('Poll module settings'),\n        'weight' => -3,\n      ),\n    ),\n    'display' => array(\n      'poll_view_voting' => array(\n        'label' => t('Poll vote'),\n        'description' => t('Poll vote'),\n        'weight' => 0,\n      ),\n      'poll_view_results' => array(\n        'label' => t('Poll results'),\n        'description' => t('Poll results'),\n        'weight' => 0,\n      ),\n    )\n  );\n\n  return $extra;\n}\n\n/**\n * Alter \"pseudo-field\" components on fieldable entities.\n *\n * @param $info\n *   The associative array of 'pseudo-field' components.\n *\n * @see hook_field_extra_fields()\n */\nfunction hook_field_extra_fields_alter(&$info) {\n  // Force node title to always be at the top of the list by default.\n  foreach (node_type_get_types() as $bundle) {\n    if (isset($info['node'][$bundle->type]['form']['title'])) {\n      $info['node'][$bundle->type]['form']['title']['weight'] = -20;\n    }\n  }\n}\n\n/**\n * @defgroup field_types Field Types API\n * @{\n * Define field types.\n *\n * In the Field API, each field has a type, which determines what kind of data\n * (integer, string, date, etc.) the field can hold, which settings it provides,\n * and so on. The data type(s) accepted by a field are defined in\n * hook_field_schema(); other basic properties of a field are defined in\n * hook_field_info(). The other hooks below are called by the Field Attach API\n * to perform field-type-specific actions.\n *\n * The Field Types API also defines two kinds of pluggable handlers: widgets\n * and formatters. @link field_widget Widgets @endlink specify how the field\n * appears in edit forms, while @link field_formatter formatters @endlink\n * specify how the field appears in displayed entities.\n *\n * A third kind of pluggable handlers, storage backends, is defined by the\n * @link field_storage Field Storage API @endlink.\n *\n * See @link field Field API @endlink for information about the other parts of\n * the Field API.\n */\n\n/**\n * Define Field API field types.\n *\n * @return\n *   An array whose keys are field type names and whose values are arrays\n *   describing the field type, with the following key/value pairs:\n *   - label: The human-readable name of the field type.\n *   - description: A short description for the field type.\n *   - settings: An array whose keys are the names of the settings available\n *     for the field type, and whose values are the default values for those\n *     settings.\n *   - instance_settings: An array whose keys are the names of the settings\n *     available for instances of the field type, and whose values are the\n *     default values for those settings. Instance-level settings can have\n *     different values on each field instance, and thus allow greater\n *     flexibility than field-level settings. It is recommended to put settings\n *     at the instance level whenever possible. Notable exceptions: settings\n *     acting on the schema definition, or settings that Views needs to use\n *     across field instances (for example, the list of allowed values).\n *   - default_widget: The machine name of the default widget to be used by\n *     instances of this field type, when no widget is specified in the\n *     instance definition. This widget must be available whenever the field\n *     type is available (i.e. provided by the field type module, or by a module\n *     the field type module depends on).\n *   - default_formatter: The machine name of the default formatter to be used\n *     by instances of this field type, when no formatter is specified in the\n *     instance definition. This formatter must be available whenever the field\n *     type is available (i.e. provided by the field type module, or by a module\n *     the field type module depends on).\n *   - no_ui: (optional) A boolean specifying that users should not be allowed\n *     to create fields and instances of this field type through the UI. Such\n *     fields can only be created programmatically with field_create_field()\n *     and field_create_instance(). Defaults to FALSE.\n *\n * @see hook_field_info_alter()\n */\nfunction hook_field_info() {\n  return array(\n    'text' => array(\n      'label' => t('Text'),\n      'description' => t('This field stores varchar text in the database.'),\n      'settings' => array('max_length' => 255),\n      'instance_settings' => array('text_processing' => 0),\n      'default_widget' => 'text_textfield',\n      'default_formatter' => 'text_default',\n    ),\n    'text_long' => array(\n      'label' => t('Long text'),\n      'description' => t('This field stores long text in the database.'),\n      'settings' => array('max_length' => ''),\n      'instance_settings' => array('text_processing' => 0),\n      'default_widget' => 'text_textarea',\n      'default_formatter' => 'text_default',\n    ),\n    'text_with_summary' => array(\n      'label' => t('Long text and summary'),\n      'description' => t('This field stores long text in the database along with optional summary text.'),\n      'settings' => array('max_length' => ''),\n      'instance_settings' => array('text_processing' => 1, 'display_summary' => 0),\n      'default_widget' => 'text_textarea_with_summary',\n      'default_formatter' => 'text_summary_or_trimmed',\n    ),\n  );\n}\n\n/**\n * Perform alterations on Field API field types.\n *\n * @param $info\n *   Array of information on field types exposed by hook_field_info()\n *   implementations.\n */\nfunction hook_field_info_alter(&$info) {\n  // Add a setting to all field types.\n  foreach ($info as $field_type => $field_type_info) {\n    $info[$field_type]['settings'] += array(\n      'mymodule_additional_setting' => 'default value',\n    );\n  }\n\n  // Change the default widget for fields of type 'foo'.\n  if (isset($info['foo'])) {\n    $info['foo']['default widget'] = 'mymodule_widget';\n  }\n}\n\n/**\n * Define the Field API schema for a field structure.\n *\n * This hook MUST be defined in .install for it to be detected during\n * installation and upgrade.\n *\n * @param $field\n *   A field structure.\n *\n * @return\n *   An associative array with the following keys:\n *   - columns: An array of Schema API column specifications, keyed by column\n *     name. This specifies what comprises a value for a given field. For\n *     example, a value for a number field is simply 'value', while a value for\n *     a formatted text field is the combination of 'value' and 'format'. It is\n *     recommended to avoid having the column definitions depend on field\n *     settings when possible. No assumptions should be made on how storage\n *     engines internally use the original column name to structure their\n *     storage.\n *   - indexes: (optional) An array of Schema API indexes definitions. Only\n *     columns that appear in the 'columns' array are allowed. Those indexes\n *     will be used as default indexes. Callers of field_create_field() can\n *     specify additional indexes, or, at their own risk, modify the default\n *     indexes specified by the field-type module. Some storage engines might\n *     not support indexes.\n *   - foreign keys: (optional) An array of Schema API foreign keys\n *     definitions.\n */\nfunction hook_field_schema($field) {\n  if ($field['type'] == 'text_long') {\n    $columns = array(\n      'value' => array(\n        'type' => 'text',\n        'size' => 'big',\n        'not null' => FALSE,\n      ),\n    );\n  }\n  else {\n    $columns = array(\n      'value' => array(\n        'type' => 'varchar',\n        'length' => $field['settings']['max_length'],\n        'not null' => FALSE,\n      ),\n    );\n  }\n  $columns += array(\n    'format' => array(\n      'type' => 'varchar',\n      'length' => 255,\n      'not null' => FALSE,\n    ),\n  );\n  return array(\n    'columns' => $columns,\n    'indexes' => array(\n      'format' => array('format'),\n    ),\n    'foreign keys' => array(\n      'format' => array(\n        'table' => 'filter_format',\n        'columns' => array('format' => 'format'),\n      ),\n    ),\n  );\n}\n\n/**\n * Define custom load behavior for this module's field types.\n *\n * Unlike most other field hooks, this hook operates on multiple entities. The\n * $entities, $instances and $items parameters are arrays keyed by entity ID.\n * For performance reasons, information for all available entity should be\n * loaded in a single query where possible.\n *\n * Note that the changes made to the field values get cached by the field cache\n * for subsequent loads. You should never use this hook to load fieldable\n * entities, since this is likely to cause infinite recursions when\n * hook_field_load() is run on those as well. Use\n * hook_field_formatter_prepare_view() instead.\n *\n * Make changes or additions to field values by altering the $items parameter by\n * reference. There is no return value.\n *\n * @param $entity_type\n *   The type of $entity.\n * @param $entities\n *   Array of entities being loaded, keyed by entity ID.\n * @param $field\n *   The field structure for the operation.\n * @param $instances\n *   Array of instance structures for $field for each entity, keyed by entity\n *   ID.\n * @param $langcode\n *   The language code associated with $items.\n * @param $items\n *   Array of field values already loaded for the entities, keyed by entity ID.\n *   Store your changes in this parameter (passed by reference).\n * @param $age\n *   FIELD_LOAD_CURRENT to load the most recent revision for all fields, or\n *   FIELD_LOAD_REVISION to load the version indicated by each entity.\n */\nfunction hook_field_load($entity_type, $entities, $field, $instances, $langcode, &$items, $age) {\n  // Sample code from text.module: precompute sanitized strings so they are\n  // stored in the field cache.\n  foreach ($entities as $id => $entity) {\n    foreach ($items[$id] as $delta => $item) {\n      // Only process items with a cacheable format, the rest will be handled\n      // by formatters if needed.\n      if (empty($instances[$id]['settings']['text_processing']) || filter_format_allowcache($item['format'])) {\n        $items[$id][$delta]['safe_value'] = isset($item['value']) ? _text_sanitize($instances[$id], $langcode, $item, 'value') : '';\n        if ($field['type'] == 'text_with_summary') {\n          $items[$id][$delta]['safe_summary'] = isset($item['summary']) ? _text_sanitize($instances[$id], $langcode, $item, 'summary') : '';\n        }\n      }\n    }\n  }\n}\n\n/**\n * Prepare field values prior to display.\n *\n * This hook is invoked before the field values are handed to formatters\n * for display, and runs before the formatters' own\n * hook_field_formatter_prepare_view().\n *\n * Unlike most other field hooks, this hook operates on multiple entities. The\n * $entities, $instances and $items parameters are arrays keyed by entity ID.\n * For performance reasons, information for all available entities should be\n * loaded in a single query where possible.\n *\n * Make changes or additions to field values by altering the $items parameter by\n * reference. There is no return value.\n *\n * @param $entity_type\n *   The type of $entity.\n * @param $entities\n *   Array of entities being displayed, keyed by entity ID.\n * @param $field\n *   The field structure for the operation.\n * @param $instances\n *   Array of instance structures for $field for each entity, keyed by entity\n *   ID.\n * @param $langcode\n *   The language associated to $items.\n * @param $items\n *   $entity->{$field['field_name']}, or an empty array if unset.\n */\nfunction hook_field_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items) {\n  // Sample code from image.module: if there are no images specified at all,\n  // use the default image.\n  foreach ($entities as $id => $entity) {\n    if (empty($items[$id]) && $field['settings']['default_image']) {\n      if ($file = file_load($field['settings']['default_image'])) {\n        $items[$id][0] = (array) $file + array(\n          'is_default' => TRUE,\n          'alt' => '',\n          'title' => '',\n        );\n      }\n    }\n  }\n}\n\n/**\n * Validate this module's field data.\n *\n * If there are validation problems, add to the $errors array (passed by\n * reference). There is no return value.\n *\n * @param $entity_type\n *   The type of $entity.\n * @param $entity\n *   The entity for the operation.\n * @param $field\n *   The field structure for the operation.\n * @param $instance\n *   The instance structure for $field on $entity's bundle.\n * @param $langcode\n *   The language associated with $items.\n * @param $items\n *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.\n * @param $errors\n *   The array of errors (keyed by field name, language code, and delta) that\n *   have already been reported for the entity. The function should add its\n *   errors to this array. Each error is an associative array with the following\n *   keys and values:\n *   - error: An error code (should be a string prefixed with the module name).\n *   - message: The human readable message to be displayed.\n */\nfunction hook_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {\n  foreach ($items as $delta => $item) {\n    if (!empty($item['value'])) {\n      if (!empty($field['settings']['max_length']) && drupal_strlen($item['value']) > $field['settings']['max_length']) {\n        $errors[$field['field_name']][$langcode][$delta][] = array(\n          'error' => 'text_max_length',\n          'message' => t('%name: the value may not be longer than %max characters.', array('%name' => $instance['label'], '%max' => $field['settings']['max_length'])),\n        );\n      }\n    }\n  }\n}\n\n/**\n * Define custom presave behavior for this module's field types.\n *\n * Make changes or additions to field values by altering the $items parameter by\n * reference. There is no return value.\n *\n * @param $entity_type\n *   The type of $entity.\n * @param $entity\n *   The entity for the operation.\n * @param $field\n *   The field structure for the operation.\n * @param $instance\n *   The instance structure for $field on $entity's bundle.\n * @param $langcode\n *   The language associated with $items.\n * @param $items\n *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.\n */\nfunction hook_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {\n  if ($field['type'] == 'number_decimal') {\n    // Let PHP round the value to ensure consistent behavior across storage\n    // backends.\n    foreach ($items as $delta => $item) {\n      if (isset($item['value'])) {\n        $items[$delta]['value'] = round($item['value'], $field['settings']['scale']);\n      }\n    }\n  }\n}\n\n/**\n * Define custom insert behavior for this module's field data.\n *\n * This hook is invoked from field_attach_insert() on the module that defines a\n * field, during the process of inserting an entity object (node, taxonomy term,\n * etc.). It is invoked just before the data for this field on the particular\n * entity object is inserted into field storage. Only field modules that are\n * storing or tracking information outside the standard field storage mechanism\n * need to implement this hook.\n *\n * @param $entity_type\n *   The type of $entity.\n * @param $entity\n *   The entity for the operation.\n * @param $field\n *   The field structure for the operation.\n * @param $instance\n *   The instance structure for $field on $entity's bundle.\n * @param $langcode\n *   The language associated with $items.\n * @param $items\n *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.\n *\n * @see hook_field_update()\n * @see hook_field_delete()\n */\nfunction hook_field_insert($entity_type, $entity, $field, $instance, $langcode, &$items) {\n  if (variable_get('taxonomy_maintain_index_table', TRUE) && $field['storage']['type'] == 'field_sql_storage' && $entity_type == 'node' && $entity->status) {\n    $query = db_insert('taxonomy_index')->fields(array('nid', 'tid', 'sticky', 'created', ));\n    foreach ($items as $item) {\n      $query->values(array(\n        'nid' => $entity->nid,\n        'tid' => $item['tid'],\n        'sticky' => $entity->sticky,\n        'created' => $entity->created,\n      ));\n    }\n    $query->execute();\n  }\n}\n\n/**\n * Define custom update behavior for this module's field data.\n *\n * This hook is invoked from field_attach_update() on the module that defines a\n * field, during the process of updating an entity object (node, taxonomy term,\n * etc.). It is invoked just before the data for this field on the particular\n * entity object is updated into field storage. Only field modules that are\n * storing or tracking information outside the standard field storage mechanism\n * need to implement this hook.\n *\n * @param $entity_type\n *   The type of $entity.\n * @param $entity\n *   The entity for the operation.\n * @param $field\n *   The field structure for the operation.\n * @param $instance\n *   The instance structure for $field on $entity's bundle.\n * @param $langcode\n *   The language associated with $items.\n * @param $items\n *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.\n *\n * @see hook_field_insert()\n * @see hook_field_delete()\n */\nfunction hook_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {\n  if (variable_get('taxonomy_maintain_index_table', TRUE) && $field['storage']['type'] == 'field_sql_storage' && $entity_type == 'node') {\n    $first_call = &drupal_static(__FUNCTION__, array());\n\n    // We don't maintain data for old revisions, so clear all previous values\n    // from the table. Since this hook runs once per field, per object, make\n    // sure we only wipe values once.\n    if (!isset($first_call[$entity->nid])) {\n      $first_call[$entity->nid] = FALSE;\n      db_delete('taxonomy_index')->condition('nid', $entity->nid)->execute();\n    }\n    // Only save data to the table if the node is published.\n    if ($entity->status) {\n      $query = db_insert('taxonomy_index')->fields(array('nid', 'tid', 'sticky', 'created'));\n      foreach ($items as $item) {\n        $query->values(array(\n          'nid' => $entity->nid,\n          'tid' => $item['tid'],\n          'sticky' => $entity->sticky,\n          'created' => $entity->created,\n        ));\n      }\n      $query->execute();\n    }\n  }\n}\n\n/**\n * Update the storage information for a field.\n *\n * This is invoked on the field's storage module from field_update_field(),\n * before the new field information is saved to the database. The field storage\n * module should update its storage tables to agree with the new field\n * information. If there is a problem, the field storage module should throw an\n * exception.\n *\n * @param $field\n *   The updated field structure to be saved.\n * @param $prior_field\n *   The previously-saved field structure.\n * @param $has_data\n *   TRUE if the field has data in storage currently.\n */\nfunction hook_field_storage_update_field($field, $prior_field, $has_data) {\n  if (!$has_data) {\n    // There is no data. Re-create the tables completely.\n    $prior_schema = _field_sql_storage_schema($prior_field);\n    foreach ($prior_schema as $name => $table) {\n      db_drop_table($name, $table);\n    }\n    $schema = _field_sql_storage_schema($field);\n    foreach ($schema as $name => $table) {\n      db_create_table($name, $table);\n    }\n  }\n  else {\n    // There is data. See field_sql_storage_field_storage_update_field() for\n    // an example of what to do to modify the schema in place, preserving the\n    // old data as much as possible.\n  }\n  drupal_get_schema(NULL, TRUE);\n}\n\n/**\n * Define custom delete behavior for this module's field data.\n *\n * This hook is invoked from field_attach_delete() on the module that defines a\n * field, during the process of deleting an entity object (node, taxonomy term,\n * etc.). It is invoked just before the data for this field on the particular\n * entity object is deleted from field storage. Only field modules that are\n * storing or tracking information outside the standard field storage mechanism\n * need to implement this hook.\n *\n * @param $entity_type\n *   The type of $entity.\n * @param $entity\n *   The entity for the operation.\n * @param $field\n *   The field structure for the operation.\n * @param $instance\n *   The instance structure for $field on $entity's bundle.\n * @param $langcode\n *   The language associated with $items.\n * @param $items\n *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.\n *\n * @see hook_field_insert()\n * @see hook_field_update()\n */\nfunction hook_field_delete($entity_type, $entity, $field, $instance, $langcode, &$items) {\n  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);\n  foreach ($items as $delta => $item) {\n    // For hook_file_references(), remember that this is being deleted.\n    $item['file_field_name'] = $field['field_name'];\n    // Pass in the ID of the object that is being removed so all references can\n    // be counted in hook_file_references().\n    $item['file_field_type'] = $entity_type;\n    $item['file_field_id'] = $id;\n    file_field_delete_file($item, $field, $entity_type, $id);\n  }\n}\n\n/**\n * Define custom revision delete behavior for this module's field types.\n *\n * This hook is invoked just before the data is deleted from field storage\n * in field_attach_delete_revision(), and will only be called for fieldable\n * types that are versioned.\n *\n * @param $entity_type\n *   The type of $entity.\n * @param $entity\n *   The entity for the operation.\n * @param $field\n *   The field structure for the operation.\n * @param $instance\n *   The instance structure for $field on $entity's bundle.\n * @param $langcode\n *   The language associated with $items.\n * @param $items\n *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.\n */\nfunction hook_field_delete_revision($entity_type, $entity, $field, $instance, $langcode, &$items) {\n  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);\n  foreach ($items as $delta => $item) {\n    // For hook_file_references, remember that this file is being deleted.\n    $item['file_field_name'] = $field['field_name'];\n    if (file_field_delete_file($item, $field, $entity_type, $id)) {\n      $items[$delta] = NULL;\n    }\n  }\n}\n\n/**\n * Define custom prepare_translation behavior for this module's field types.\n *\n * @param $entity_type\n *   The type of $entity.\n * @param $entity\n *   The entity for the operation.\n * @param $field\n *   The field structure for the operation.\n * @param $instance\n *   The instance structure for $field on $entity's bundle.\n * @param $langcode\n *   The language associated to $items.\n * @param $items\n *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.\n * @param $source_entity\n *   The source entity from which field values are being copied.\n * @param $source_langcode\n *   The source language from which field values are being copied.\n */\nfunction hook_field_prepare_translation($entity_type, $entity, $field, $instance, $langcode, &$items, $source_entity, $source_langcode) {\n  // If the translating user is not permitted to use the assigned text format,\n  // we must not expose the source values.\n  $field_name = $field['field_name'];\n  $formats = filter_formats();\n  $format_id = $source_entity->{$field_name}[$source_langcode][0]['format'];\n  if (!filter_access($formats[$format_id])) {\n    $items = array();\n  }\n}\n\n/**\n * Define what constitutes an empty item for a field type.\n *\n * @param $item\n *   An item that may or may not be empty.\n * @param $field\n *   The field to which $item belongs.\n *\n * @return\n *   TRUE if $field's type considers $item not to contain any data;\n *   FALSE otherwise.\n */\nfunction hook_field_is_empty($item, $field) {\n  if (empty($item['value']) && (string) $item['value'] !== '0') {\n    return TRUE;\n  }\n  return FALSE;\n}\n\n/**\n * @} End of \"defgroup field_types\".\n */\n\n/**\n * @defgroup field_widget Field Widget API\n * @{\n * Define Field API widget types.\n *\n * Field API widgets specify how fields are displayed in edit forms. Fields of a\n * given @link field_types field type @endlink may be edited using more than one\n * widget. In this case, the Field UI module allows the site builder to choose\n * which widget to use. Widget types are defined by implementing\n * hook_field_widget_info().\n *\n * Widgets are @link forms_api_reference.html Form API @endlink elements with\n * additional processing capabilities. Widget hooks are typically called by the\n * Field Attach API during the creation of the field form structure with\n * field_attach_form().\n *\n * @see field\n * @see field_types\n * @see field_formatter\n */\n\n/**\n * Expose Field API widget types.\n *\n * @return\n *   An array describing the widget types implemented by the module.\n *   The keys are widget type names. To avoid name clashes, widget type\n *   names should be prefixed with the name of the module that exposes them.\n *   The values are arrays describing the widget type, with the following\n *   key/value pairs:\n *   - label: The human-readable name of the widget type.\n *   - description: A short description for the widget type.\n *   - field types: An array of field types the widget supports.\n *   - settings: An array whose keys are the names of the settings available\n *     for the widget type, and whose values are the default values for those\n *     settings.\n *   - behaviors: (optional) An array describing behaviors of the widget, with\n *     the following elements:\n *     - multiple values: One of the following constants:\n *       - FIELD_BEHAVIOR_DEFAULT: (default) If the widget allows the input of\n *         one single field value (most common case). The widget will be\n *         repeated for each value input.\n *       - FIELD_BEHAVIOR_CUSTOM: If one single copy of the widget can receive\n *         several field values. Examples: checkboxes, multiple select,\n *         comma-separated textfield.\n *     - default value: One of the following constants:\n *       - FIELD_BEHAVIOR_DEFAULT: (default) If the widget accepts default\n *         values.\n *       - FIELD_BEHAVIOR_NONE: if the widget does not support default values.\n *   - weight: (optional) An integer to determine the weight of this widget\n *     relative to other widgets in the Field UI when selecting a widget for a\n *     given field instance.\n *\n * @see hook_field_widget_info_alter()\n * @see hook_field_widget_form()\n * @see hook_field_widget_form_alter()\n * @see hook_field_widget_WIDGET_TYPE_form_alter()\n * @see hook_field_widget_error()\n * @see hook_field_widget_settings_form()\n */\nfunction hook_field_widget_info() {\n  return array(\n    'text_textfield' => array(\n      'label' => t('Text field'),\n      'field types' => array('text'),\n      'settings' => array('size' => 60),\n      'behaviors' => array(\n        'multiple values' => FIELD_BEHAVIOR_DEFAULT,\n        'default value' => FIELD_BEHAVIOR_DEFAULT,\n      ),\n    ),\n    'text_textarea' => array(\n      'label' => t('Text area (multiple rows)'),\n      'field types' => array('text_long'),\n      'settings' => array('rows' => 5),\n      'behaviors' => array(\n        'multiple values' => FIELD_BEHAVIOR_DEFAULT,\n        'default value' => FIELD_BEHAVIOR_DEFAULT,\n      ),\n    ),\n    'text_textarea_with_summary' => array(\n      'label' => t('Text area with a summary'),\n      'field types' => array('text_with_summary'),\n      'settings' => array('rows' => 20, 'summary_rows' => 5),\n      'behaviors' => array(\n        'multiple values' => FIELD_BEHAVIOR_DEFAULT,\n        'default value' => FIELD_BEHAVIOR_DEFAULT,\n      ),\n      // As an advanced widget, force it to sink to the bottom of the choices.\n      'weight' => 2,\n    ),\n  );\n}\n\n/**\n * Perform alterations on Field API widget types.\n *\n * @param $info\n *   Array of informations on widget types exposed by hook_field_widget_info()\n *   implementations.\n */\nfunction hook_field_widget_info_alter(&$info) {\n  // Add a setting to a widget type.\n  $info['text_textfield']['settings'] += array(\n    'mymodule_additional_setting' => 'default value',\n  );\n\n  // Let a new field type re-use an existing widget.\n  $info['options_select']['field types'][] = 'my_field_type';\n}\n\n/**\n * Return the form for a single field widget.\n *\n * Field widget form elements should be based on the passed-in $element, which\n * contains the base form element properties derived from the field\n * configuration.\n *\n * Field API will set the weight, field name and delta values for each form\n * element. If there are multiple values for this field, the Field API will\n * invoke this hook as many times as needed.\n *\n * Note that, depending on the context in which the widget is being included\n * (regular entity form, field configuration form, advanced search form...),\n * the values for $field and $instance might be different from the \"official\"\n * definitions returned by field_info_field() and field_info_instance().\n * Examples: mono-value widget even if the field is multi-valued, non-required\n * widget even if the field is 'required'...\n *\n * Therefore, the FAPI element callbacks (such as #process, #element_validate,\n * #value_callback...) used by the widget cannot use the field_info_field()\n * or field_info_instance() functions to retrieve the $field or $instance\n * definitions they should operate on. The field_widget_field() and\n * field_widget_instance() functions should be used instead to fetch the\n * current working definitions from $form_state, where Field API stores them.\n *\n * Alternatively, hook_field_widget_form() can extract the needed specific\n * properties from $field and $instance and set them as ad-hoc\n * $element['#custom'] properties, for later use by its element callbacks.\n *\n * Other modules may alter the form element provided by this function using\n * hook_field_widget_form_alter().\n *\n * @param $form\n *   The form structure where widgets are being attached to. This might be a\n *   full form structure, or a sub-element of a larger form.\n * @param $form_state\n *   An associative array containing the current state of the form.\n * @param $field\n *   The field structure.\n * @param $instance\n *   The field instance.\n * @param $langcode\n *   The language associated with $items.\n * @param $items\n *   Array of default values for this field.\n * @param $delta\n *   The order of this item in the array of subelements (0, 1, 2, etc).\n * @param $element\n *   A form element array containing basic properties for the widget:\n *   - #entity_type: The name of the entity the field is attached to.\n *   - #bundle: The name of the field bundle the field is contained in.\n *   - #field_name: The name of the field.\n *   - #language: The language the field is being edited in.\n *   - #field_parents: The 'parents' space for the field in the form. Most\n *       widgets can simply overlook this property. This identifies the\n *       location where the field values are placed within\n *       $form_state['values'], and is used to access processing information\n *       for the field through the field_form_get_state() and\n *       field_form_set_state() functions.\n *   - #columns: A list of field storage columns of the field.\n *   - #title: The sanitized element label for the field instance, ready for\n *     output.\n *   - #description: The sanitized element description for the field instance,\n *     ready for output.\n *   - #required: A Boolean indicating whether the element value is required;\n *     for required multiple value fields, only the first widget's values are\n *     required.\n *   - #delta: The order of this item in the array of subelements; see $delta\n *     above.\n *\n * @return\n *   The form elements for a single widget for this field.\n *\n * @see field_widget_field()\n * @see field_widget_instance()\n * @see hook_field_widget_form_alter()\n * @see hook_field_widget_WIDGET_TYPE_form_alter()\n */\nfunction hook_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {\n  $element += array(\n    '#type' => $instance['widget']['type'],\n    '#default_value' => isset($items[$delta]) ? $items[$delta] : '',\n  );\n  return $element;\n}\n\n/**\n * Alter forms for field widgets provided by other modules.\n *\n * @param $element\n *   The field widget form element as constructed by hook_field_widget_form().\n * @param $form_state\n *   An associative array containing the current state of the form.\n * @param $context\n *   An associative array containing the following key-value pairs, matching the\n *   arguments received by hook_field_widget_form():\n *   - form: The form structure to which widgets are being attached. This may be\n *     a full form structure, or a sub-element of a larger form.\n *   - field: The field structure.\n *   - instance: The field instance structure.\n *   - langcode: The language associated with $items.\n *   - items: Array of default values for this field.\n *   - delta: The order of this item in the array of subelements (0, 1, 2, etc).\n *\n * @see hook_field_widget_form()\n * @see hook_field_widget_WIDGET_TYPE_form_alter()\n */\nfunction hook_field_widget_form_alter(&$element, &$form_state, $context) {\n  // Add a css class to widget form elements for all fields of type mytype.\n  if ($context['field']['type'] == 'mytype') {\n    // Be sure not to overwrite existing attributes.\n    $element['#attributes']['class'][] = 'myclass';\n  }\n}\n\n/**\n * Alter widget forms for a specific widget provided by another module.\n *\n * Modules can implement hook_field_widget_WIDGET_TYPE_form_alter() to modify a\n * specific widget form, rather than using hook_field_widget_form_alter() and\n * checking the widget type.\n *\n * @param $element\n *   The field widget form element as constructed by hook_field_widget_form().\n * @param $form_state\n *   An associative array containing the current state of the form.\n * @param $context\n *   An associative array containing the following key-value pairs, matching the\n *   arguments received by hook_field_widget_form():\n *   - \"form\": The form structure where widgets are being attached to. This\n *     might be a full form structure, or a sub-element of a larger form.\n *   - \"field\": The field structure.\n *   - \"instance\": The field instance structure.\n *   - \"langcode\": The language associated with $items.\n *   - \"items\": Array of default values for this field.\n *   - \"delta\": The order of this item in the array of subelements (0, 1, 2,\n *     etc).\n *\n * @see hook_field_widget_form()\n * @see hook_field_widget_form_alter()\n */\nfunction hook_field_widget_WIDGET_TYPE_form_alter(&$element, &$form_state, $context) {\n  // Code here will only act on widgets of type WIDGET_TYPE.  For example,\n  // hook_field_widget_mymodule_autocomplete_form_alter() will only act on\n  // widgets of type 'mymodule_autocomplete'.\n  $element['#autocomplete_path'] = 'mymodule/autocomplete_path';\n}\n\n/**\n * Alters the widget properties of a field instance before it gets displayed.\n *\n * Note that instead of hook_field_widget_properties_alter(), which is called\n * for all fields on all entity types,\n * hook_field_widget_properties_ENTITY_TYPE_alter() may be used to alter widget\n * properties for fields on a specific entity type only.\n *\n * This hook is called once per field per added or edit entity. If the result\n * of the hook involves reading from the database, it is highly recommended to\n * statically cache the information.\n *\n * @param $widget\n *   The instance's widget properties.\n * @param $context\n *   An associative array containing:\n *   - entity_type: The entity type; e.g., 'node' or 'user'.\n *   - entity: The entity object.\n *   - field: The field that the widget belongs to.\n *   - instance: The instance of the field.\n *\n * @see hook_field_widget_properties_ENTITY_TYPE_alter()\n */\nfunction hook_field_widget_properties_alter(&$widget, $context) {\n  // Change a widget's type according to the time of day.\n  $field = $context['field'];\n  if ($context['entity_type'] == 'node' && $field['field_name'] == 'field_foo') {\n    $time = date('H');\n    $widget['type'] = $time < 12 ? 'widget_am' : 'widget_pm';\n  }\n}\n\n/**\n * Flag a field-level validation error.\n *\n * @param $element\n *   An array containing the form element for the widget. The error needs to be\n *   flagged on the right sub-element, according to the widget's internal\n *   structure.\n * @param $error\n *   An associative array with the following key-value pairs, as returned by\n *   hook_field_validate():\n *   - error: the error code. Complex widgets might need to report different\n *     errors to different form elements inside the widget.\n *   - message: the human readable message to be displayed.\n * @param $form\n *   The form structure where field elements are attached to. This might be a\n *   full form structure, or a sub-element of a larger form.\n * @param $form_state\n *   An associative array containing the current state of the form.\n */\nfunction hook_field_widget_error($element, $error, $form, &$form_state) {\n  form_error($element, $error['message']);\n}\n\n\n/**\n * @} End of \"defgroup field_widget\".\n */\n\n\n/**\n * @defgroup field_formatter Field Formatter API\n * @{\n * Define Field API formatter types.\n *\n * Field API formatters specify how fields are displayed when the entity to\n * which the field is attached is displayed. Fields of a given\n * @link field_types field type @endlink may be displayed using more than one\n * formatter. In this case, the Field UI module allows the site builder to\n * choose which formatter to use. Field formatters are defined by implementing\n * hook_field_formatter_info().\n *\n * @see field\n * @see field_types\n * @see field_widget\n */\n\n/**\n * Expose Field API formatter types.\n *\n * Formatters handle the display of field values. Formatter hooks are typically\n * called by the Field Attach API field_attach_prepare_view() and\n * field_attach_view() functions.\n *\n * @return\n *   An array describing the formatter types implemented by the module.\n *   The keys are formatter type names. To avoid name clashes, formatter type\n *   names should be prefixed with the name of the module that exposes them.\n *   The values are arrays describing the formatter type, with the following\n *   key/value pairs:\n *   - label: The human-readable name of the formatter type.\n *   - description: A short description for the formatter type.\n *   - field types: An array of field types the formatter supports.\n *   - settings: An array whose keys are the names of the settings available\n *     for the formatter type, and whose values are the default values for\n *     those settings.\n *\n * @see hook_field_formatter_info_alter()\n * @see hook_field_formatter_view()\n * @see hook_field_formatter_prepare_view()\n */\nfunction hook_field_formatter_info() {\n  return array(\n    'text_default' => array(\n      'label' => t('Default'),\n      'field types' => array('text', 'text_long', 'text_with_summary'),\n    ),\n    'text_plain' => array(\n      'label' => t('Plain text'),\n      'field types' => array('text', 'text_long', 'text_with_summary'),\n    ),\n\n    // The text_trimmed formatter displays the trimmed version of the\n    // full element of the field. It is intended to be used with text\n    // and text_long fields. It also works with text_with_summary\n    // fields though the text_summary_or_trimmed formatter makes more\n    // sense for that field type.\n    'text_trimmed' => array(\n      'label' => t('Trimmed'),\n      'field types' => array('text', 'text_long', 'text_with_summary'),\n    ),\n\n    // The 'summary or trimmed' field formatter for text_with_summary\n    // fields displays returns the summary element of the field or, if\n    // the summary is empty, the trimmed version of the full element\n    // of the field.\n    'text_summary_or_trimmed' => array(\n      'label' => t('Summary or trimmed'),\n      'field types' => array('text_with_summary'),\n    ),\n  );\n}\n\n/**\n * Perform alterations on Field API formatter types.\n *\n * @param $info\n *   An array of information on formatter types exposed by\n *   hook_field_formatter_info() implementations.\n */\nfunction hook_field_formatter_info_alter(&$info) {\n  // Add a setting to a formatter type.\n  $info['text_default']['settings'] += array(\n    'mymodule_additional_setting' => 'default value',\n  );\n\n  // Let a new field type re-use an existing formatter.\n  $info['text_default']['field types'][] = 'my_field_type';\n}\n\n/**\n * Allow formatters to load information for field values being displayed.\n *\n * This should be used when a formatter needs to load additional information\n * from the database in order to render a field, for example a reference field\n * which displays properties of the referenced entities such as name or type.\n *\n * This hook is called after the field type's own hook_field_prepare_view().\n *\n * Unlike most other field hooks, this hook operates on multiple entities. The\n * $entities, $instances and $items parameters are arrays keyed by entity ID.\n * For performance reasons, information for all available entities should be\n * loaded in a single query where possible.\n *\n * @param $entity_type\n *   The type of $entity.\n * @param $entities\n *   Array of entities being displayed, keyed by entity ID.\n * @param $field\n *   The field structure for the operation.\n * @param $instances\n *   Array of instance structures for $field for each entity, keyed by entity\n *   ID.\n * @param $langcode\n *   The language the field values are to be shown in. If no language is\n *   provided the current language is used.\n * @param $items\n *   Array of field values for the entities, keyed by entity ID.\n * @param $displays\n *   Array of display settings to use for each entity, keyed by entity ID.\n *\n * @return\n *   Changes or additions to field values are done by altering the $items\n *   parameter by reference.\n */\nfunction hook_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {\n  $tids = array();\n\n  // Collect every possible term attached to any of the fieldable entities.\n  foreach ($entities as $id => $entity) {\n    foreach ($items[$id] as $delta => $item) {\n      // Force the array key to prevent duplicates.\n      $tids[$item['tid']] = $item['tid'];\n    }\n  }\n\n  if ($tids) {\n    $terms = taxonomy_term_load_multiple($tids);\n\n    // Iterate through the fieldable entities again to attach the loaded term\n    // data.\n    foreach ($entities as $id => $entity) {\n      $rekey = FALSE;\n\n      foreach ($items[$id] as $delta => $item) {\n        // Check whether the taxonomy term field instance value could be loaded.\n        if (isset($terms[$item['tid']])) {\n          // Replace the instance value with the term data.\n          $items[$id][$delta]['taxonomy_term'] = $terms[$item['tid']];\n        }\n        // Otherwise, unset the instance value, since the term does not exist.\n        else {\n          unset($items[$id][$delta]);\n          $rekey = TRUE;\n        }\n      }\n\n      if ($rekey) {\n        // Rekey the items array.\n        $items[$id] = array_values($items[$id]);\n      }\n    }\n  }\n}\n\n/**\n * Build a renderable array for a field value.\n *\n * @param $entity_type\n *   The type of $entity.\n * @param $entity\n *   The entity being displayed.\n * @param $field\n *   The field structure.\n * @param $instance\n *   The field instance.\n * @param $langcode\n *   The language associated with $items.\n * @param $items\n *   Array of values for this field.\n * @param $display\n *   The display settings to use, as found in the 'display' entry of instance\n *   definitions. The array notably contains the following keys and values;\n *   - type: The name of the formatter to use.\n *   - settings: The array of formatter settings.\n *\n * @return\n *   A renderable array for the $items, as an array of child elements keyed\n *   by numeric indexes starting from 0.\n */\nfunction hook_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {\n  $element = array();\n  $settings = $display['settings'];\n\n  switch ($display['type']) {\n    case 'sample_field_formatter_simple':\n      // Common case: each value is displayed individually in a sub-element\n      // keyed by delta. The field.tpl.php template specifies the markup\n      // wrapping each value.\n      foreach ($items as $delta => $item) {\n        $element[$delta] = array('#markup' => $settings['some_setting'] . $item['value']);\n      }\n      break;\n\n    case 'sample_field_formatter_themeable':\n      // More elaborate formatters can defer to a theme function for easier\n      // customization.\n      foreach ($items as $delta => $item) {\n        $element[$delta] = array(\n          '#theme' => 'mymodule_theme_sample_field_formatter_themeable',\n          '#data' => $item['value'],\n          '#some_setting' => $settings['some_setting'],\n        );\n      }\n      break;\n\n    case 'sample_field_formatter_combined':\n      // Some formatters might need to display all values within a single piece\n      // of markup.\n      $rows = array();\n      foreach ($items as $delta => $item) {\n        $rows[] = array($delta, $item['value']);\n      }\n      $element[0] = array(\n        '#theme' => 'table',\n        '#header' => array(t('Delta'), t('Value')),\n        '#rows' => $rows,\n      );\n      break;\n  }\n\n  return $element;\n}\n\n/**\n * @} End of \"defgroup field_formatter\".\n */\n\n/**\n * @ingroup field_attach\n * @{\n */\n\n/**\n * Act on field_attach_form().\n *\n * This hook is invoked after the field module has performed the operation.\n * Implementing modules should alter the $form or $form_state parameters.\n *\n * @param $entity_type\n *   The type of $entity; for example, 'node' or 'user'.\n * @param $entity\n *   The entity for which an edit form is being built.\n * @param $form\n *   The form structure where field elements are attached to. This might be a\n *   full form structure, or a sub-element of a larger form. The\n *   $form['#parents'] property can be used to identify the corresponding part\n *   of $form_state['values']. Hook implementations that need to act on the\n *   top-level properties of the global form (like #submit, #validate...) can\n *   add a #process callback to the array received in the $form parameter, and\n *   act on the $complete_form parameter in the process callback.\n * @param $form_state\n *   An associative array containing the current state of the form.\n * @param $langcode\n *   The language the field values are going to be entered in. If no language\n *   is provided the default site language will be used.\n */\nfunction hook_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {\n  // Add a checkbox allowing a given field to be emptied.\n  // See hook_field_attach_submit() for the corresponding processing code.\n  $form['empty_field_foo'] = array(\n    '#type' => 'checkbox',\n    '#title' => t(\"Empty the 'field_foo' field\"),\n  );\n}\n\n/**\n * Act on field_attach_load().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * Unlike other field_attach hooks, this hook accounts for 'multiple loads'.\n * Instead of the usual $entity parameter, it accepts an array of entities,\n * indexed by entity ID. For performance reasons, information for all available\n * entities should be loaded in a single query where possible.\n *\n * The changes made to the entities' field values get cached by the field cache\n * for subsequent loads.\n *\n * See field_attach_load() for details and arguments.\n */\nfunction hook_field_attach_load($entity_type, $entities, $age, $options) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on field_attach_validate().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * See field_attach_validate() for details and arguments.\n */\nfunction hook_field_attach_validate($entity_type, $entity, &$errors) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on field_attach_submit().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * @param $entity_type\n *   The type of $entity; for example, 'node' or 'user'.\n * @param $entity\n *   The entity for which an edit form is being submitted. The incoming form\n *   values have been extracted as field values of the $entity object.\n * @param $form\n *   The form structure where field elements are attached to. This might be a\n *   full form structure, or a sub-part of a larger form. The $form['#parents']\n *   property can be used to identify the corresponding part of\n *   $form_state['values'].\n * @param $form_state\n *   An associative array containing the current state of the form.\n */\nfunction hook_field_attach_submit($entity_type, $entity, $form, &$form_state) {\n  // Sample case of an 'Empty the field' checkbox added on the form, allowing\n  // a given field to be emptied.\n  $values = drupal_array_get_nested_value($form_state['values'], $form['#parents']);\n  if (!empty($values['empty_field_foo'])) {\n    unset($entity->field_foo);\n  }\n}\n\n/**\n * Act on field_attach_presave().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * See field_attach_presave() for details and arguments.\n */\nfunction hook_field_attach_presave($entity_type, $entity) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on field_attach_insert().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * See field_attach_insert() for details and arguments.\n */\nfunction hook_field_attach_insert($entity_type, $entity) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on field_attach_update().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * See field_attach_update() for details and arguments.\n */\nfunction hook_field_attach_update($entity_type, $entity) {\n  // @todo Needs function body.\n}\n\n/**\n * Alter field_attach_preprocess() variables.\n *\n * This hook is invoked while preprocessing the field.tpl.php template file\n * in field_attach_preprocess().\n *\n * @param $variables\n *   The variables array is passed by reference and will be populated with field\n *   values.\n * @param $context\n *   An associative array containing:\n *   - entity_type: The type of $entity; for example, 'node' or 'user'.\n *   - entity: The entity with fields to render.\n *   - element: The structured array containing the values ready for rendering.\n */\nfunction hook_field_attach_preprocess_alter(&$variables, $context) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on field_attach_delete().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * See field_attach_delete() for details and arguments.\n */\nfunction hook_field_attach_delete($entity_type, $entity) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on field_attach_delete_revision().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * See field_attach_delete_revision() for details and arguments.\n */\nfunction hook_field_attach_delete_revision($entity_type, $entity) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on field_purge_data().\n *\n * This hook is invoked in field_purge_data() and allows modules to act on\n * purging data from a single field pseudo-entity. For example, if a module\n * relates data in the field with its own data, it may purge its own data\n * during this process as well.\n *\n * @param $entity_type\n *   The type of $entity; for example, 'node' or 'user'.\n * @param $entity\n *   The pseudo-entity whose field data is being purged.\n * @param $field\n *   The (possibly deleted) field whose data is being purged.\n * @param $instance\n *   The deleted field instance whose data is being purged.\n *\n * @see @link field_purge Field API bulk data deletion @endlink\n * @see field_purge_data()\n */\nfunction hook_field_attach_purge($entity_type, $entity, $field, $instance) {\n  // find the corresponding data in mymodule and purge it\n  if ($entity_type == 'node' && $field->field_name == 'my_field_name') {\n    mymodule_remove_mydata($entity->nid);\n  }\n}\n\n/**\n * Perform alterations on field_attach_view() or field_view_field().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * @param $output\n *   The structured content array tree for all of the entity's fields.\n * @param $context\n *   An associative array containing:\n *   - entity_type: The type of $entity; for example, 'node' or 'user'.\n *   - entity: The entity with fields to render.\n *   - view_mode: View mode; for example, 'full' or 'teaser'.\n *   - display: Either a view mode string or an array of display settings. If\n *     this hook is being invoked from field_attach_view(), the 'display'\n *     element is set to the view mode string. If this hook is being invoked\n *     from field_view_field(), this element is set to the $display argument\n *     and the view_mode element is set to '_custom'. See field_view_field()\n *     for more information on what its $display argument contains.\n *   - language: The language code used for rendering.\n */\nfunction hook_field_attach_view_alter(&$output, $context) {\n  // Append RDF term mappings on displayed taxonomy links.\n  foreach (element_children($output) as $field_name) {\n    $element = &$output[$field_name];\n    if ($element['#field_type'] == 'taxonomy_term_reference' && $element['#formatter'] == 'taxonomy_term_reference_link') {\n      foreach ($element['#items'] as $delta => $item) {\n        $term = $item['taxonomy_term'];\n        if (!empty($term->rdf_mapping['rdftype'])) {\n          $element[$delta]['#options']['attributes']['typeof'] = $term->rdf_mapping['rdftype'];\n        }\n        if (!empty($term->rdf_mapping['name']['predicates'])) {\n          $element[$delta]['#options']['attributes']['property'] = $term->rdf_mapping['name']['predicates'];\n        }\n      }\n    }\n  }\n}\n\n/**\n * Perform alterations on field_attach_prepare_translation().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * @param $entity\n *   The entity being prepared for translation.\n * @param $context\n *   An associative array containing:\n *   - entity_type: The type of $entity; e.g. 'node' or 'user'.\n *   - langcode: The language the entity has to be translated in.\n *   - source_entity: The entity holding the field values to be translated.\n *   - source_langcode: The source language from which translate.\n */\nfunction hook_field_attach_prepare_translation_alter(&$entity, $context) {\n  if ($context['entity_type'] == 'custom_entity_type') {\n    $entity->custom_field = $context['source_entity']->custom_field;\n  }\n}\n\n/**\n * Perform alterations on field_language() values.\n *\n * This hook is invoked to alter the array of display languages for the given\n * entity.\n *\n * @param $display_language\n *   A reference to an array of language codes keyed by field name.\n * @param $context\n *   An associative array containing:\n *   - entity_type: The type of the entity to be displayed.\n *   - entity: The entity with fields to render.\n *   - langcode: The language code $entity has to be displayed in.\n */\nfunction hook_field_language_alter(&$display_language, $context) {\n  // Do not apply core language fallback rules if they are disabled or if Locale\n  // is not registered as a translation handler.\n  if (variable_get('locale_field_language_fallback', TRUE) && field_has_translation_handler($context['entity_type'], 'locale')) {\n    locale_field_language_fallback($display_language, $context['entity'], $context['language']);\n  }\n}\n\n/**\n * Alter field_available_languages() values.\n *\n * This hook is invoked from field_available_languages() to allow modules to\n * alter the array of available languages for the given field.\n *\n * @param $languages\n *   A reference to an array of language codes to be made available.\n * @param $context\n *   An associative array containing:\n *   - entity_type: The type of the entity the field is attached to.\n *   - field: A field data structure.\n */\nfunction hook_field_available_languages_alter(&$languages, $context) {\n  // Add an unavailable language.\n  $languages[] = 'xx';\n\n  // Remove an available language.\n  $index = array_search('yy', $languages);\n  unset($languages[$index]);\n}\n\n/**\n * Act on field_attach_create_bundle().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * See field_attach_create_bundle() for details and arguments.\n */\nfunction hook_field_attach_create_bundle($entity_type, $bundle) {\n  // When a new bundle is created, the menu needs to be rebuilt to add the\n  // Field UI menu item tabs.\n  variable_set('menu_rebuild_needed', TRUE);\n}\n\n/**\n * Act on field_attach_rename_bundle().\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * See field_attach_rename_bundle() for details and arguments.\n */\nfunction hook_field_attach_rename_bundle($entity_type, $bundle_old, $bundle_new) {\n  // Update the extra weights variable with new information.\n  if ($bundle_old !== $bundle_new) {\n    $extra_weights = variable_get('field_extra_weights', array());\n    if (isset($info[$entity_type][$bundle_old])) {\n      $extra_weights[$entity_type][$bundle_new] = $extra_weights[$entity_type][$bundle_old];\n      unset($extra_weights[$entity_type][$bundle_old]);\n      variable_set('field_extra_weights', $extra_weights);\n    }\n  }\n}\n\n/**\n * Act on field_attach_delete_bundle.\n *\n * This hook is invoked after the field module has performed the operation.\n *\n * @param $entity_type\n *   The type of entity; for example, 'node' or 'user'.\n * @param $bundle\n *   The bundle that was just deleted.\n * @param $instances\n *   An array of all instances that existed for the bundle before it was\n *   deleted.\n */\nfunction hook_field_attach_delete_bundle($entity_type, $bundle, $instances) {\n  // Remove the extra weights variable information for this bundle.\n  $extra_weights = variable_get('field_extra_weights', array());\n  if (isset($extra_weights[$entity_type][$bundle])) {\n    unset($extra_weights[$entity_type][$bundle]);\n    variable_set('field_extra_weights', $extra_weights);\n  }\n}\n\n/**\n * @} End of \"defgroup field_attach\".\n */\n\n/**\n * @addtogroup field_storage\n * @{\n */\n\n/**\n * Expose Field API storage backends.\n *\n * @return\n *   An array describing the storage backends implemented by the module.\n *   The keys are storage backend names. To avoid name clashes, storage backend\n *   names should be prefixed with the name of the module that exposes them.\n *   The values are arrays describing the storage backend, with the following\n *   key/value pairs:\n *   - label: The human-readable name of the storage backend.\n *   - description: A short description for the storage backend.\n *   - settings: An array whose keys are the names of the settings available\n *     for the storage backend, and whose values are the default values for\n *     those settings.\n */\nfunction hook_field_storage_info() {\n  return array(\n    'field_sql_storage' => array(\n      'label' => t('Default SQL storage'),\n      'description' => t('Stores fields in the local SQL database, using per-field tables.'),\n      'settings' => array(),\n    ),\n  );\n}\n\n/**\n * Perform alterations on Field API storage types.\n *\n * @param $info\n *   Array of informations on storage types exposed by\n *   hook_field_field_storage_info() implementations.\n */\nfunction hook_field_storage_info_alter(&$info) {\n  // Add a setting to a storage type.\n  $info['field_sql_storage']['settings'] += array(\n    'mymodule_additional_setting' => 'default value',\n  );\n}\n\n/**\n * Reveal the internal details about the storage for a field.\n *\n * For example, an SQL storage module might return the Schema API structure for\n * the table. A key/value storage module might return the server name,\n * authentication credentials, and bin name.\n *\n * Field storage modules are not obligated to implement this hook. Modules\n * that rely on these details must only use them for read operations.\n *\n * @param $field\n *   A field structure.\n *\n * @return\n *   An array of details.\n *    - The first dimension is a store type (sql, solr, etc).\n *    - The second dimension indicates the age of the values in the store\n *      FIELD_LOAD_CURRENT or FIELD_LOAD_REVISION.\n *    - Other dimensions are specific to the field storage module.\n *\n * @see hook_field_storage_details_alter()\n */\nfunction hook_field_storage_details($field) {\n  $details = array();\n\n  // Add field columns.\n  foreach ((array) $field['columns'] as $column_name => $attributes) {\n    $real_name = _field_sql_storage_columnname($field['field_name'], $column_name);\n    $columns[$column_name] = $real_name;\n  }\n  return array(\n    'sql' => array(\n      FIELD_LOAD_CURRENT => array(\n        _field_sql_storage_tablename($field) => $columns,\n      ),\n      FIELD_LOAD_REVISION => array(\n        _field_sql_storage_revision_tablename($field) => $columns,\n      ),\n    ),\n  );\n}\n\n/**\n * Perform alterations on Field API storage details.\n *\n * @param $details\n *   An array of storage details for fields as exposed by\n *   hook_field_storage_details() implementations.\n * @param $field\n *   A field structure.\n *\n * @see hook_field_storage_details()\n */\nfunction hook_field_storage_details_alter(&$details, $field) {\n  if ($field['field_name'] == 'field_of_interest') {\n    $columns = array();\n    foreach ((array) $field['columns'] as $column_name => $attributes) {\n      $columns[$column_name] = $column_name;\n    }\n    $details['drupal_variables'] = array(\n      FIELD_LOAD_CURRENT => array(\n        'moon' => $columns,\n      ),\n      FIELD_LOAD_REVISION => array(\n        'mars' => $columns,\n      ),\n    );\n  }\n}\n\n/**\n * Load field data for a set of entities.\n *\n * This hook is invoked from field_attach_load() to ask the field storage\n * module to load field data.\n *\n * Modules implementing this hook should load field values and add them to\n * objects in $entities. Fields with no values should be added as empty\n * arrays.\n *\n * @param $entity_type\n *   The type of entity, such as 'node' or 'user'.\n * @param $entities\n *   The array of entity objects to add fields to, keyed by entity ID.\n * @param $age\n *   FIELD_LOAD_CURRENT to load the most recent revision for all fields, or\n *   FIELD_LOAD_REVISION to load the version indicated by each entity.\n * @param $fields\n *   An array listing the fields to be loaded. The keys of the array are field\n *   IDs, and the values of the array are the entity IDs (or revision IDs,\n *   depending on the $age parameter) to add each field to.\n * @param $options\n *   An associative array of additional options, with the following keys:\n *   - deleted: If TRUE, deleted fields should be loaded as well as\n *     non-deleted fields. If unset or FALSE, only non-deleted fields should be\n *     loaded.\n */\nfunction hook_field_storage_load($entity_type, $entities, $age, $fields, $options) {\n  $field_info = field_info_field_by_ids();\n  $load_current = $age == FIELD_LOAD_CURRENT;\n\n  foreach ($fields as $field_id => $ids) {\n    $field = $field_info[$field_id];\n    $field_name = $field['field_name'];\n    $table = $load_current ? _field_sql_storage_tablename($field) : _field_sql_storage_revision_tablename($field);\n\n    $query = db_select($table, 't')\n      ->fields('t')\n      ->condition('entity_type', $entity_type)\n      ->condition($load_current ? 'entity_id' : 'revision_id', $ids, 'IN')\n      ->condition('language', field_available_languages($entity_type, $field), 'IN')\n      ->orderBy('delta');\n\n    if (empty($options['deleted'])) {\n      $query->condition('deleted', 0);\n    }\n\n    $results = $query->execute();\n\n    $delta_count = array();\n    foreach ($results as $row) {\n      if (!isset($delta_count[$row->entity_id][$row->language])) {\n        $delta_count[$row->entity_id][$row->language] = 0;\n      }\n\n      if ($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED || $delta_count[$row->entity_id][$row->language] < $field['cardinality']) {\n        $item = array();\n        // For each column declared by the field, populate the item\n        // from the prefixed database column.\n        foreach ($field['columns'] as $column => $attributes) {\n          $column_name = _field_sql_storage_columnname($field_name, $column);\n          $item[$column] = $row->$column_name;\n        }\n\n        // Add the item to the field values for the entity.\n        $entities[$row->entity_id]->{$field_name}[$row->language][] = $item;\n        $delta_count[$row->entity_id][$row->language]++;\n      }\n    }\n  }\n}\n\n/**\n * Write field data for an entity.\n *\n * This hook is invoked from field_attach_insert() and field_attach_update(),\n * to ask the field storage module to save field data.\n *\n * @param $entity_type\n *   The entity type of entity, such as 'node' or 'user'.\n * @param $entity\n *   The entity on which to operate.\n * @param $op\n *   FIELD_STORAGE_UPDATE when updating an existing entity,\n *   FIELD_STORAGE_INSERT when inserting a new entity.\n * @param $fields\n *   An array listing the fields to be written. The keys and values of the\n *   array are field IDs.\n */\nfunction hook_field_storage_write($entity_type, $entity, $op, $fields) {\n  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);\n  if (!isset($vid)) {\n    $vid = $id;\n  }\n\n  foreach ($fields as $field_id) {\n    $field = field_info_field_by_id($field_id);\n    $field_name = $field['field_name'];\n    $table_name = _field_sql_storage_tablename($field);\n    $revision_name = _field_sql_storage_revision_tablename($field);\n\n    $all_languages = field_available_languages($entity_type, $field);\n    $field_languages = array_intersect($all_languages, array_keys((array) $entity->$field_name));\n\n    // Delete and insert, rather than update, in case a value was added.\n    if ($op == FIELD_STORAGE_UPDATE) {\n      // Delete languages present in the incoming $entity->$field_name.\n      // Delete all languages if $entity->$field_name is empty.\n      $languages = !empty($entity->$field_name) ? $field_languages : $all_languages;\n      if ($languages) {\n        db_delete($table_name)\n          ->condition('entity_type', $entity_type)\n          ->condition('entity_id', $id)\n          ->condition('language', $languages, 'IN')\n          ->execute();\n        db_delete($revision_name)\n          ->condition('entity_type', $entity_type)\n          ->condition('entity_id', $id)\n          ->condition('revision_id', $vid)\n          ->condition('language', $languages, 'IN')\n          ->execute();\n      }\n    }\n\n    // Prepare the multi-insert query.\n    $do_insert = FALSE;\n    $columns = array('entity_type', 'entity_id', 'revision_id', 'bundle', 'delta', 'language');\n    foreach ($field['columns'] as $column => $attributes) {\n      $columns[] = _field_sql_storage_columnname($field_name, $column);\n    }\n    $query = db_insert($table_name)->fields($columns);\n    $revision_query = db_insert($revision_name)->fields($columns);\n\n    foreach ($field_languages as $langcode) {\n      $items = (array) $entity->{$field_name}[$langcode];\n      $delta_count = 0;\n      foreach ($items as $delta => $item) {\n        // We now know we have someting to insert.\n        $do_insert = TRUE;\n        $record = array(\n          'entity_type' => $entity_type,\n          'entity_id' => $id,\n          'revision_id' => $vid,\n          'bundle' => $bundle,\n          'delta' => $delta,\n          'language' => $langcode,\n        );\n        foreach ($field['columns'] as $column => $attributes) {\n          $record[_field_sql_storage_columnname($field_name, $column)] = isset($item[$column]) ? $item[$column] : NULL;\n        }\n        $query->values($record);\n        if (isset($vid)) {\n          $revision_query->values($record);\n        }\n\n        if ($field['cardinality'] != FIELD_CARDINALITY_UNLIMITED && ++$delta_count == $field['cardinality']) {\n          break;\n        }\n      }\n    }\n\n    // Execute the query if we have values to insert.\n    if ($do_insert) {\n      $query->execute();\n      $revision_query->execute();\n    }\n  }\n}\n\n/**\n * Delete all field data for an entity.\n *\n * This hook is invoked from field_attach_delete() to ask the field storage\n * module to delete field data.\n *\n * @param $entity_type\n *   The entity type of entity, such as 'node' or 'user'.\n * @param $entity\n *   The entity on which to operate.\n * @param $fields\n *   An array listing the fields to delete. The keys and values of the\n *   array are field IDs.\n */\nfunction hook_field_storage_delete($entity_type, $entity, $fields) {\n  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);\n\n  foreach (field_info_instances($entity_type, $bundle) as $instance) {\n    if (isset($fields[$instance['field_id']])) {\n      $field = field_info_field_by_id($instance['field_id']);\n      field_sql_storage_field_storage_purge($entity_type, $entity, $field, $instance);\n    }\n  }\n}\n\n/**\n * Delete a single revision of field data for an entity.\n *\n * This hook is invoked from field_attach_delete_revision() to ask the field\n * storage module to delete field revision data.\n *\n * Deleting the current (most recently written) revision is not\n * allowed as has undefined results.\n *\n * @param $entity_type\n *   The entity type of entity, such as 'node' or 'user'.\n * @param $entity\n *   The entity on which to operate. The revision to delete is\n *   indicated by the entity's revision ID property, as identified by\n *   hook_fieldable_info() for $entity_type.\n * @param $fields\n *   An array listing the fields to delete. The keys and values of the\n *   array are field IDs.\n */\nfunction hook_field_storage_delete_revision($entity_type, $entity, $fields) {\n  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);\n\n  if (isset($vid)) {\n    foreach ($fields as $field_id) {\n      $field = field_info_field_by_id($field_id);\n      $revision_name = _field_sql_storage_revision_tablename($field);\n      db_delete($revision_name)\n        ->condition('entity_type', $entity_type)\n        ->condition('entity_id', $id)\n        ->condition('revision_id', $vid)\n        ->execute();\n    }\n  }\n}\n\n/**\n * Execute an EntityFieldQuery.\n *\n * This hook is called to find the entities having certain entity and field\n * conditions and sort them in the given field order. If the field storage\n * engine also handles property sorts and orders, it should unset those\n * properties in the called object to signal that those have been handled.\n *\n * @param EntityFieldQuery $query\n *   An EntityFieldQuery.\n *\n * @return\n *   See EntityFieldQuery::execute() for the return values.\n */\nfunction hook_field_storage_query($query) {\n  $groups = array();\n  if ($query->age == FIELD_LOAD_CURRENT) {\n    $tablename_function = '_field_sql_storage_tablename';\n    $id_key = 'entity_id';\n  }\n  else {\n    $tablename_function = '_field_sql_storage_revision_tablename';\n    $id_key = 'revision_id';\n  }\n  $table_aliases = array();\n  // Add tables for the fields used.\n  foreach ($query->fields as $key => $field) {\n    $tablename = $tablename_function($field);\n    // Every field needs a new table.\n    $table_alias = $tablename . $key;\n    $table_aliases[$key] = $table_alias;\n    if ($key) {\n      $select_query->join($tablename, $table_alias, \"$table_alias.entity_type = $field_base_table.entity_type AND $table_alias.$id_key = $field_base_table.$id_key\");\n    }\n    else {\n      $select_query = db_select($tablename, $table_alias);\n      $select_query->addTag('entity_field_access');\n      $select_query->addMetaData('base_table', $tablename);\n      $select_query->fields($table_alias, array('entity_type', 'entity_id', 'revision_id', 'bundle'));\n      $field_base_table = $table_alias;\n    }\n    if ($field['cardinality'] != 1) {\n      $select_query->distinct();\n    }\n  }\n\n  // Add field conditions.\n  foreach ($query->fieldConditions as $key => $condition) {\n    $table_alias = $table_aliases[$key];\n    $field = $condition['field'];\n    // Add the specified condition.\n    $sql_field = \"$table_alias.\" . _field_sql_storage_columnname($field['field_name'], $condition['column']);\n    $query->addCondition($select_query, $sql_field, $condition);\n    // Add delta / language group conditions.\n    foreach (array('delta', 'language') as $column) {\n      if (isset($condition[$column . '_group'])) {\n        $group_name = $condition[$column . '_group'];\n        if (!isset($groups[$column][$group_name])) {\n          $groups[$column][$group_name] = $table_alias;\n        }\n        else {\n          $select_query->where(\"$table_alias.$column = \" . $groups[$column][$group_name] . \".$column\");\n        }\n      }\n    }\n  }\n\n  if (isset($query->deleted)) {\n    $select_query->condition(\"$field_base_table.deleted\", (int) $query->deleted);\n  }\n\n  // Is there a need to sort the query by property?\n  $has_property_order = FALSE;\n  foreach ($query->order as $order) {\n    if ($order['type'] == 'property') {\n      $has_property_order = TRUE;\n    }\n  }\n\n  if ($query->propertyConditions || $has_property_order) {\n    if (empty($query->entityConditions['entity_type']['value'])) {\n      throw new EntityFieldQueryException('Property conditions and orders must have an entity type defined.');\n    }\n    $entity_type = $query->entityConditions['entity_type']['value'];\n    $entity_base_table = _field_sql_storage_query_join_entity($select_query, $entity_type, $field_base_table);\n    $query->entityConditions['entity_type']['operator'] = '=';\n    foreach ($query->propertyConditions as $property_condition) {\n      $query->addCondition($select_query, \"$entity_base_table.\" . $property_condition['column'], $property_condition);\n    }\n  }\n  foreach ($query->entityConditions as $key => $condition) {\n    $query->addCondition($select_query, \"$field_base_table.$key\", $condition);\n  }\n\n  // Order the query.\n  foreach ($query->order as $order) {\n    if ($order['type'] == 'entity') {\n      $key = $order['specifier'];\n      $select_query->orderBy(\"$field_base_table.$key\", $order['direction']);\n    }\n    elseif ($order['type'] == 'field') {\n      $specifier = $order['specifier'];\n      $field = $specifier['field'];\n      $table_alias = $table_aliases[$specifier['index']];\n      $sql_field = \"$table_alias.\" . _field_sql_storage_columnname($field['field_name'], $specifier['column']);\n      $select_query->orderBy($sql_field, $order['direction']);\n    }\n    elseif ($order['type'] == 'property') {\n      $select_query->orderBy(\"$entity_base_table.\" . $order['specifier'], $order['direction']);\n    }\n  }\n\n  return $query->finishQuery($select_query, $id_key);\n}\n\n/**\n * Act on creation of a new field.\n *\n * This hook is invoked from field_create_field() to ask the field storage\n * module to save field information and prepare for storing field instances.\n * If there is a problem, the field storage module should throw an exception.\n *\n * @param $field\n *   The field structure being created.\n */\nfunction hook_field_storage_create_field($field) {\n  $schema = _field_sql_storage_schema($field);\n  foreach ($schema as $name => $table) {\n    db_create_table($name, $table);\n  }\n  drupal_get_schema(NULL, TRUE);\n}\n\n/**\n * Act on deletion of a field.\n *\n * This hook is invoked from field_delete_field() to ask the field storage\n * module to mark all information stored in the field for deletion.\n *\n * @param $field\n *   The field being deleted.\n */\nfunction hook_field_storage_delete_field($field) {\n  // Mark all data associated with the field for deletion.\n  $field['deleted'] = 0;\n  $table = _field_sql_storage_tablename($field);\n  $revision_table = _field_sql_storage_revision_tablename($field);\n  db_update($table)\n    ->fields(array('deleted' => 1))\n    ->execute();\n\n  // Move the table to a unique name while the table contents are being deleted.\n  $field['deleted'] = 1;\n  $new_table = _field_sql_storage_tablename($field);\n  $revision_new_table = _field_sql_storage_revision_tablename($field);\n  db_rename_table($table, $new_table);\n  db_rename_table($revision_table, $revision_new_table);\n  drupal_get_schema(NULL, TRUE);\n}\n\n/**\n * Act on deletion of a field instance.\n *\n * This hook is invoked from field_delete_instance() to ask the field storage\n * module to mark all information stored for the field instance for deletion.\n *\n * @param $instance\n *   The instance being deleted.\n */\nfunction hook_field_storage_delete_instance($instance) {\n  $field = field_info_field($instance['field_name']);\n  $table_name = _field_sql_storage_tablename($field);\n  $revision_name = _field_sql_storage_revision_tablename($field);\n  db_update($table_name)\n    ->fields(array('deleted' => 1))\n    ->condition('entity_type', $instance['entity_type'])\n    ->condition('bundle', $instance['bundle'])\n    ->execute();\n  db_update($revision_name)\n    ->fields(array('deleted' => 1))\n    ->condition('entity_type', $instance['entity_type'])\n    ->condition('bundle', $instance['bundle'])\n    ->execute();\n}\n\n/**\n * Act before the storage backends load field data.\n *\n * This hook allows modules to load data before the Field Storage API,\n * optionally preventing the field storage module from doing so.\n *\n * This lets 3rd party modules override, mirror, shard, or otherwise store a\n * subset of fields in a different way than the current storage engine.\n * Possible use cases include per-bundle storage, per-combo-field storage, etc.\n *\n * Modules implementing this hook should load field values and add them to\n * objects in $entities. Fields with no values should be added as empty\n * arrays. In addition, fields loaded should be added as keys to $skip_fields.\n *\n * @param $entity_type\n *   The type of entity, such as 'node' or 'user'.\n * @param $entities\n *   The array of entity objects to add fields to, keyed by entity ID.\n * @param $age\n *   FIELD_LOAD_CURRENT to load the most recent revision for all fields, or\n *   FIELD_LOAD_REVISION to load the version indicated by each entity.\n * @param $skip_fields\n *   An array keyed by field IDs whose data has already been loaded and\n *   therefore should not be loaded again. Add a key to this array to indicate\n *   that your module has already loaded a field.\n * @param $options\n *   An associative array of additional options, with the following keys:\n *   - field_id: The field ID that should be loaded. If unset, all fields\n *     should be loaded.\n *   - deleted: If TRUE, deleted fields should be loaded as well as\n *     non-deleted fields. If unset or FALSE, only non-deleted fields should be\n *     loaded.\n */\nfunction hook_field_storage_pre_load($entity_type, $entities, $age, &$skip_fields, $options) {\n  // @todo Needs function body.\n}\n\n/**\n * Act before the storage backends insert field data.\n *\n * This hook allows modules to store data before the Field Storage API,\n * optionally preventing the field storage module from doing so.\n *\n * @param $entity_type\n *   The type of $entity; for example, 'node' or 'user'.\n * @param $entity\n *   The entity with fields to save.\n * @param $skip_fields\n *   An array keyed by field IDs whose data has already been written and\n *   therefore should not be written again. The values associated with these\n *   keys are not specified.\n * @return\n *   Saved field IDs are set set as keys in $skip_fields.\n */\nfunction hook_field_storage_pre_insert($entity_type, $entity, &$skip_fields) {\n  if ($entity_type == 'node' && $entity->status && _forum_node_check_node_type($entity)) {\n    $query = db_insert('forum_index')->fields(array('nid', 'title', 'tid', 'sticky', 'created', 'comment_count', 'last_comment_timestamp'));\n    foreach ($entity->taxonomy_forums as $language) {\n      foreach ($language as $delta) {\n        $query->values(array(\n          'nid' => $entity->nid,\n          'title' => $entity->title,\n          'tid' => $delta['value'],\n          'sticky' => $entity->sticky,\n          'created' => $entity->created,\n          'comment_count' => 0,\n          'last_comment_timestamp' => $entity->created,\n        ));\n      }\n    }\n    $query->execute();\n  }\n}\n\n/**\n * Act before the storage backends update field data.\n *\n * This hook allows modules to store data before the Field Storage API,\n * optionally preventing the field storage module from doing so.\n *\n * @param $entity_type\n *   The type of $entity; for example, 'node' or 'user'.\n * @param $entity\n *   The entity with fields to save.\n * @param $skip_fields\n *   An array keyed by field IDs whose data has already been written and\n *   therefore should not be written again. The values associated with these\n *   keys are not specified.\n * @return\n *   Saved field IDs are set set as keys in $skip_fields.\n */\nfunction hook_field_storage_pre_update($entity_type, $entity, &$skip_fields) {\n  $first_call = &drupal_static(__FUNCTION__, array());\n\n  if ($entity_type == 'node' && $entity->status && _forum_node_check_node_type($entity)) {\n    // We don't maintain data for old revisions, so clear all previous values\n    // from the table. Since this hook runs once per field, per entity, make\n    // sure we only wipe values once.\n    if (!isset($first_call[$entity->nid])) {\n      $first_call[$entity->nid] = FALSE;\n      db_delete('forum_index')->condition('nid', $entity->nid)->execute();\n    }\n    // Only save data to the table if the node is published.\n    if ($entity->status) {\n      $query = db_insert('forum_index')->fields(array('nid', 'title', 'tid', 'sticky', 'created', 'comment_count', 'last_comment_timestamp'));\n      foreach ($entity->taxonomy_forums as $language) {\n        foreach ($language as $delta) {\n          $query->values(array(\n            'nid' => $entity->nid,\n            'title' => $entity->title,\n            'tid' => $delta['value'],\n            'sticky' => $entity->sticky,\n            'created' => $entity->created,\n            'comment_count' => 0,\n            'last_comment_timestamp' => $entity->created,\n          ));\n        }\n      }\n      $query->execute();\n      // The logic for determining last_comment_count is fairly complex, so\n      // call _forum_update_forum_index() too.\n      _forum_update_forum_index($entity->nid);\n    }\n  }\n}\n\n/**\n * Returns the maximum weight for the entity components handled by the module.\n *\n * Field API takes care of fields and 'extra_fields'. This hook is intended for\n * third-party modules adding other entity components (e.g. field_group).\n *\n * @param $entity_type\n *   The type of entity; e.g. 'node' or 'user'.\n * @param $bundle\n *   The bundle name.\n * @param $context\n *   The context for which the maximum weight is requested. Either 'form', or\n *   the name of a view mode.\n * @return\n *   The maximum weight of the entity's components, or NULL if no components\n *   were found.\n */\nfunction hook_field_info_max_weight($entity_type, $bundle, $context) {\n  $weights = array();\n\n  foreach (my_module_entity_additions($entity_type, $bundle, $context) as $addition) {\n    $weights[] = $addition['weight'];\n  }\n\n  return $weights ? max($weights) : NULL;\n}\n\n/**\n * Alters the display settings of a field before it gets displayed.\n *\n * Note that instead of hook_field_display_alter(), which is called for all\n * fields on all entity types, hook_field_display_ENTITY_TYPE_alter() may be\n * used to alter display settings for fields on a specific entity type only.\n *\n * This hook is called once per field per displayed entity. If the result of the\n * hook involves reading from the database, it is highly recommended to\n * statically cache the information.\n *\n * @param $display\n *   The display settings that will be used to display the field values, as\n *   found in the 'display' key of $instance definitions.\n * @param $context\n *   An associative array containing:\n *   - entity_type: The entity type; e.g., 'node' or 'user'.\n *   - field: The field being rendered.\n *   - instance: The instance being rendered.\n *   - entity: The entity being rendered.\n *   - view_mode: The view mode, e.g. 'full', 'teaser'...\n *\n * @see hook_field_display_ENTITY_TYPE_alter()\n */\nfunction hook_field_display_alter(&$display, $context) {\n  // Leave field labels out of the search index.\n  // Note: The check against $context['entity_type'] == 'node' could be avoided\n  // by using hook_field_display_node_alter() instead of\n  // hook_field_display_alter(), resulting in less function calls when\n  // rendering non-node entities.\n  if ($context['entity_type'] == 'node' && $context['view_mode'] == 'search_index') {\n    $display['label'] = 'hidden';\n  }\n}\n\n/**\n * Alters the display settings of a field on a given entity type before it gets displayed.\n *\n * Modules can implement hook_field_display_ENTITY_TYPE_alter() to alter display\n * settings for fields on a specific entity type, rather than implementing\n * hook_field_display_alter().\n *\n * This hook is called once per field per displayed entity. If the result of the\n * hook involves reading from the database, it is highly recommended to\n * statically cache the information.\n *\n * @param $display\n *   The display settings that will be used to display the field values, as\n *   found in the 'display' key of $instance definitions.\n * @param $context\n *   An associative array containing:\n *   - entity_type: The entity type; e.g., 'node' or 'user'.\n *   - field: The field being rendered.\n *   - instance: The instance being rendered.\n *   - entity: The entity being rendered.\n *   - view_mode: The view mode, e.g. 'full', 'teaser'...\n *\n * @see hook_field_display_alter()\n */\nfunction hook_field_display_ENTITY_TYPE_alter(&$display, $context) {\n  // Leave field labels out of the search index.\n  if ($context['view_mode'] == 'search_index') {\n    $display['label'] = 'hidden';\n  }\n}\n\n/**\n * Alters the display settings of pseudo-fields before an entity is displayed.\n *\n * This hook is called once per displayed entity. If the result of the hook\n * involves reading from the database, it is highly recommended to statically\n * cache the information.\n *\n * @param $displays\n *   An array of display settings for the pseudo-fields in the entity, keyed\n *   by pseudo-field names.\n * @param $context\n *   An associative array containing:\n *   - entity_type: The entity type; e.g., 'node' or 'user'.\n *   - bundle: The bundle name.\n *   - view_mode: The view mode, e.g. 'full', 'teaser'...\n */\nfunction hook_field_extra_fields_display_alter(&$displays, $context) {\n  if ($context['entity_type'] == 'taxonomy_term' && $context['view_mode'] == 'full') {\n    $displays['description']['visible'] = FALSE;\n  }\n}\n\n/**\n * Alters the widget properties of a field instance on a given entity type\n * before it gets displayed.\n *\n * Modules can implement hook_field_widget_properties_ENTITY_TYPE_alter() to\n * alter the widget properties for fields on a specific entity type, rather than\n * implementing hook_field_widget_properties_alter().\n *\n * This hook is called once per field per displayed widget entity. If the result\n * of the hook involves reading from the database, it is highly recommended to\n * statically cache the information.\n *\n * @param $widget\n *   The instance's widget properties.\n * @param $context\n *   An associative array containing:\n *   - entity_type: The entity type; e.g., 'node' or 'user'.\n *   - entity: The entity object.\n *   - field: The field that the widget belongs to.\n *   - instance: The instance of the field.\n *\n * @see hook_field_widget_properties_alter()\n */\nfunction hook_field_widget_properties_ENTITY_TYPE_alter(&$widget, $context) {\n  // Change a widget's type according to the time of day.\n  $field = $context['field'];\n  if ($field['field_name'] == 'field_foo') {\n    $time = date('H');\n    $widget['type'] = $time < 12 ? 'widget_am' : 'widget_pm';\n  }\n}\n\n/**\n * @} End of \"addtogroup field_storage\".\n */\n\n/**\n * @addtogroup field_crud\n * @{\n */\n\n/**\n * Act on a field being created.\n *\n * This hook is invoked from field_create_field() after the field is created, to\n * allow modules to act on field creation.\n *\n * @param $field\n *   The field just created.\n */\nfunction hook_field_create_field($field) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on a field instance being created.\n *\n * This hook is invoked from field_create_instance() after the instance record\n * is saved, so it cannot be used to modify the instance itself.\n *\n * @param $instance\n *   The instance just created.\n */\nfunction hook_field_create_instance($instance) {\n  // @todo Needs function body.\n}\n\n/**\n * Forbid a field update from occurring.\n *\n * Any module may forbid any update for any reason. For example, the\n * field's storage module might forbid an update if it would change\n * the storage schema while data for the field exists. A field type\n * module might forbid an update if it would change existing data's\n * semantics, or if there are external dependencies on field settings\n * that cannot be updated.\n *\n * To forbid the update from occurring, throw a FieldUpdateForbiddenException.\n *\n * @param $field\n *   The field as it will be post-update.\n * @param $prior_field\n *   The field as it is pre-update.\n * @param $has_data\n *   Whether any data already exists for this field.\n */\nfunction hook_field_update_forbid($field, $prior_field, $has_data) {\n  // A 'list' field stores integer keys mapped to display values. If\n  // the new field will have fewer values, and any data exists for the\n  // abandoned keys, the field will have no way to display them. So,\n  // forbid such an update.\n  if ($has_data && count($field['settings']['allowed_values']) < count($prior_field['settings']['allowed_values'])) {\n    // Identify the keys that will be lost.\n    $lost_keys = array_diff(array_keys($field['settings']['allowed_values']), array_keys($prior_field['settings']['allowed_values']));\n    // If any data exist for those keys, forbid the update.\n    $query = new EntityFieldQuery();\n    $found = $query\n      ->fieldCondition($prior_field['field_name'], 'value', $lost_keys)\n      ->range(0, 1)\n      ->execute();\n    if ($found) {\n      throw new FieldUpdateForbiddenException(\"Cannot update a list field not to include keys with existing data\");\n    }\n  }\n}\n\n/**\n * Act on a field being updated.\n *\n * This hook is invoked just after field is updated in field_update_field().\n *\n * @param $field\n *   The field as it is post-update.\n * @param $prior_field\n *   The field as it was pre-update.\n * @param $has_data\n *   Whether any data already exists for this field.\n */\nfunction hook_field_update_field($field, $prior_field, $has_data) {\n  // Reset the static value that keeps track of allowed values for list fields.\n  drupal_static_reset('list_allowed_values');\n}\n\n/**\n * Act on a field being deleted.\n *\n * This hook is invoked just after a field is deleted by field_delete_field().\n *\n * @param $field\n *   The field just deleted.\n */\nfunction hook_field_delete_field($field) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on a field instance being updated.\n *\n * This hook is invoked from field_update_instance() after the instance record\n * is saved, so it cannot be used by a module to modify the instance itself.\n *\n * @param $instance\n *   The instance as it is post-update.\n * @param $prior_$instance\n *   The instance as it was pre-update.\n */\nfunction hook_field_update_instance($instance, $prior_instance) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on a field instance being deleted.\n *\n * This hook is invoked from field_delete_instance() after the instance is\n * deleted.\n *\n * @param $instance\n *   The instance just deleted.\n */\nfunction hook_field_delete_instance($instance) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on field records being read from the database.\n *\n * This hook is invoked from field_read_fields() on each field being read.\n *\n * @param $field\n *   The field record just read from the database.\n */\nfunction hook_field_read_field($field) {\n  // @todo Needs function body.\n}\n\n/**\n * Act on a field record being read from the database.\n *\n * This hook is invoked from field_read_instances() on each instance being read.\n *\n * @param $instance\n *   The instance record just read from the database.\n */\nfunction hook_field_read_instance($instance) {\n  // @todo Needs function body.\n}\n\n/**\n * Acts when a field record is being purged.\n *\n * In field_purge_field(), after the field configuration has been\n * removed from the database, the field storage module has had a chance to\n * run its hook_field_storage_purge_field(), and the field info cache\n * has been cleared, this hook is invoked on all modules to allow them to\n * respond to the field being purged.\n *\n * @param $field\n *   The field being purged.\n */\nfunction hook_field_purge_field($field) {\n  db_delete('my_module_field_info')\n    ->condition('id', $field['id'])\n    ->execute();\n}\n\n/**\n * Acts when a field instance is being purged.\n *\n * In field_purge_instance(), after the field instance has been\n * removed from the database, the field storage module has had a chance to\n * run its hook_field_storage_purge_instance(), and the field info cache\n * has been cleared, this hook is invoked on all modules to allow them to\n * respond to the field instance being purged.\n *\n * @param $instance\n *   The instance being purged.\n */\nfunction hook_field_purge_instance($instance) {\n  db_delete('my_module_field_instance_info')\n    ->condition('id', $instance['id'])\n    ->execute();\n}\n\n/**\n * Remove field storage information when a field record is purged.\n *\n * Called from field_purge_field() to allow the field storage module\n * to remove field information when a field is being purged.\n *\n * @param $field\n *   The field being purged.\n */\nfunction hook_field_storage_purge_field($field) {\n  $table_name = _field_sql_storage_tablename($field);\n  $revision_name = _field_sql_storage_revision_tablename($field);\n  db_drop_table($table_name);\n  db_drop_table($revision_name);\n}\n\n/**\n * Remove field storage information when a field instance is purged.\n *\n * Called from field_purge_instance() to allow the field storage module\n * to remove field instance information when a field instance is being\n * purged.\n *\n * @param $instance\n *   The instance being purged.\n */\nfunction hook_field_storage_purge_field_instance($instance) {\n  db_delete('my_module_field_instance_info')\n    ->condition('id', $instance['id'])\n    ->execute();\n}\n\n/**\n * Remove field storage information when field data is purged.\n *\n * Called from field_purge_data() to allow the field storage\n * module to delete field data information.\n *\n * @param $entity_type\n *   The type of $entity; for example, 'node' or 'user'.\n * @param $entity\n *   The pseudo-entity whose field data to delete.\n * @param $field\n *   The (possibly deleted) field whose data is being purged.\n * @param $instance\n *   The deleted field instance whose data is being purged.\n */\nfunction hook_field_storage_purge($entity_type, $entity, $field, $instance) {\n  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);\n\n  $table_name = _field_sql_storage_tablename($field);\n  $revision_name = _field_sql_storage_revision_tablename($field);\n  db_delete($table_name)\n    ->condition('entity_type', $entity_type)\n    ->condition('entity_id', $id)\n    ->execute();\n  db_delete($revision_name)\n    ->condition('entity_type', $entity_type)\n    ->condition('entity_id', $id)\n    ->execute();\n}\n\n/**\n * @} End of \"addtogroup field_crud\".\n */\n\n/**\n * Determine whether the user has access to a given field.\n *\n * This hook is invoked from field_access() to let modules block access to\n * operations on fields. If no module returns FALSE, the operation is allowed.\n *\n * @param $op\n *   The operation to be performed. Possible values: 'edit', 'view'.\n * @param $field\n *   The field on which the operation is to be performed.\n * @param $entity_type\n *   The type of $entity; for example, 'node' or 'user'.\n * @param $entity\n *   (optional) The entity for the operation.\n * @param $account\n *   (optional) The account to check; if not given use currently logged in user.\n *\n * @return\n *   TRUE if the operation is allowed, and FALSE if the operation is denied.\n */\nfunction hook_field_access($op, $field, $entity_type, $entity, $account) {\n  if ($field['field_name'] == 'field_of_interest' && $op == 'edit') {\n    return user_access('edit field of interest', $account);\n  }\n  return TRUE;\n}\n\n/**\n * @} End of \"addtogroup hooks\".\n */",
  "language": "PHP",
}