{
    "name": "newText.py",
    "timestamp": "2012-11-02T16:05:51Z",
    "source": "\"\"\"\nThis module converts requested URLs to callback view functions.\n\nRegexURLResolver is the main class here. Its resolve() method takes a URL (as\na string) and returns a tuple in this format:\n\n    (view_function, function_args, function_kwargs)\n\"\"\"\nfrom __future__ import unicode_literals\n\nimport re\nfrom threading import local\n\nfrom django.http import Http404\nfrom django.core.exceptions import ImproperlyConfigured, ViewDoesNotExist\nfrom django.utils.datastructures import MultiValueDict\nfrom django.utils.encoding import force_str, force_text, iri_to_uri\nfrom django.utils.functional import memoize, lazy\nfrom django.utils.importlib import import_module\nfrom django.utils.module_loading import module_has_submodule\nfrom django.utils.regex_helper import normalize\nfrom django.utils import six\nfrom django.utils.translation import get_language\n\n\n_resolver_cache = {} # Maps URLconf modules to RegexURLResolver instances.\n_ns_resolver_cache = {} # Maps namespaces to RegexURLResolver instances.\n_callable_cache = {} # Maps view and url pattern names to their view functions.\n\n# SCRIPT_NAME prefixes for each thread are stored here. If there's no entry for\n# the current thread (which is the only one we ever access), it is assumed to\n# be empty.\n_prefixes = local()\n\n# Overridden URLconfs for each thread are stored here.\n_urlconfs = local()\n\n\nclass ResolverMatch(object):\n    def __init__(self, func, args, kwargs, url_name=None, app_name=None, namespaces=None):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n        self.app_name = app_name\n        if namespaces:\n            self.namespaces = [x for x in namespaces if x]\n        else:\n            self.namespaces = []\n        if not url_name:\n            if not hasattr(func, '__name__'):\n                # An instance of a callable class\n                url_name = '.'.join([func.__class__.__module__, func.__class__.__name__])\n            else:\n                # A function\n                url_name = '.'.join([func.__module__, func.__name__])\n        self.url_name = url_name\n\n    @property\n    def namespace(self):\n        return ':'.join(self.namespaces)\n\n    @property\n    def view_name(self):\n        return ':'.join([ x for x in [ self.namespace, self.url_name ]  if x ])\n\n    def __getitem__(self, index):\n        return (self.func, self.args, self.kwargs)[index]\n\n    def __repr__(self):\n        return \"ResolverMatch(func=%s, args=%s, kwargs=%s, url_name='%s', app_name='%s', namespace='%s')\" % (\n            self.func, self.args, self.kwargs, self.url_name, self.app_name, self.namespace)\n\nclass Resolver404(Http404):\n    pass\n\nclass NoReverseMatch(Exception):\n    # Don't make this raise an error when used in a template.\n    silent_variable_failure = True\n\ndef get_callable(lookup_view, can_fail=False):\n    \"\"\"\n    Convert a string version of a function name to the callable object.\n\n    If the lookup_view is not an import path, it is assumed to be a URL pattern\n    label and the original string is returned.\n\n    If can_fail is True, lookup_view might be a URL pattern label, so errors\n    during the import fail and the string is returned.\n    \"\"\"\n    if not callable(lookup_view):\n        mod_name, func_name = get_mod_func(lookup_view)\n        if func_name == '':\n            return lookup_view\n\n        try:\n            mod = import_module(mod_name)\n        except ImportError:\n            parentmod, submod = get_mod_func(mod_name)\n            if (not can_fail and submod != '' and\n                    not module_has_submodule(import_module(parentmod), submod)):\n                raise ViewDoesNotExist(\n                    \"Could not import %s. Parent module %s does not exist.\" %\n                    (lookup_view, mod_name))\n            if not can_fail:\n                raise\n        else:\n            try:\n                lookup_view = getattr(mod, func_name)\n                if not callable(lookup_view):\n                    raise ViewDoesNotExist(\n                        \"Could not import %s.%s. View is not callable.\" %\n                        (mod_name, func_name))\n            except AttributeError:\n                if not can_fail:\n                    raise ViewDoesNotExist(\n                        \"Could not import %s. View does not exist in module %s.\" %\n                        (lookup_view, mod_name))\n    return lookup_view\nget_callable = memoize(get_callable, _callable_cache, 1)\n\ndef get_resolver(urlconf):\n    if urlconf is None:\n        from django.conf import settings\n        urlconf = settings.ROOT_URLCONF\n    return RegexURLResolver(r'^/', urlconf)\nget_resolver = memoize(get_resolver, _resolver_cache, 1)\n\ndef get_ns_resolver(ns_pattern, resolver):\n    # Build a namespaced resolver for the given parent urlconf pattern.\n    # This makes it possible to have captured parameters in the parent\n    # urlconf pattern.\n    ns_resolver = RegexURLResolver(ns_pattern,\n                                          resolver.url_patterns)\n    return RegexURLResolver(r'^/', [ns_resolver])\nget_ns_resolver = memoize(get_ns_resolver, _ns_resolver_cache, 2)\n\ndef get_mod_func(callback):\n    # Converts 'django.views.news.stories.story_detail' to\n    # ['django.views.news.stories', 'story_detail']\n    try:\n        dot = callback.rindex('.')\n    except ValueError:\n        return callback, ''\n    return callback[:dot], callback[dot+1:]\n\nclass LocaleRegexProvider(object):\n    \"\"\"\n    A mixin to provide a default regex property which can vary by active\n    language.\n\n    \"\"\"\n    def __init__(self, regex):\n        # regex is either a string representing a regular expression, or a\n        # translatable string (using ugettext_lazy) representing a regular\n        # expression.\n        self._regex = regex\n        self._regex_dict = {}\n\n\n    @property\n    def regex(self):\n        \"\"\"\n        Returns a compiled regular expression, depending upon the activated\n        language-code.\n        \"\"\"\n        language_code = get_language()\n        if language_code not in self._regex_dict:\n            if isinstance(self._regex, six.string_types):\n                regex = self._regex\n            else:\n                regex = force_text(self._regex)\n            try:\n                compiled_regex = re.compile(regex, re.UNICODE)\n            except re.error as e:\n                raise ImproperlyConfigured(\n                    '\"%s\" is not a valid regular expression: %s' %\n                    (regex, six.text_type(e)))\n\n            self._regex_dict[language_code] = compiled_regex\n        return self._regex_dict[language_code]\n\n\nclass RegexURLPattern(LocaleRegexProvider):\n    def __init__(self, regex, callback, default_args=None, name=None):\n        LocaleRegexProvider.__init__(self, regex)\n        # callback is either a string like 'foo.views.news.stories.story_detail'\n        # which represents the path to a module and a view function name, or a\n        # callable object (view).\n        if callable(callback):\n            self._callback = callback\n        else:\n            self._callback = None\n            self._callback_str = callback\n        self.default_args = default_args or {}\n        self.name = name\n\n    def __repr__(self):\n        return force_str('<%s %s %s>' % (self.__class__.__name__, self.name, self.regex.pattern))\n\n    def add_prefix(self, prefix):\n        \"\"\"\n        Adds the prefix string to a string-based callback.\n        \"\"\"\n        if not prefix or not hasattr(self, '_callback_str'):\n            return\n        self._callback_str = prefix + '.' + self._callback_str\n\n    def resolve(self, path):\n        match = self.regex.search(path)\n        if match:\n            # If there are any named groups, use those as kwargs, ignoring\n            # non-named groups. Otherwise, pass all non-named arguments as\n            # positional arguments.\n            kwargs = match.groupdict()\n            if kwargs:\n                args = ()\n            else:\n                args = match.groups()\n            # In both cases, pass any extra_kwargs as **kwargs.\n            kwargs.update(self.default_args)\n\n            return ResolverMatch(self.callback, args, kwargs, self.name)\n\n    @property\n    def callback(self):\n        if self._callback is not None:\n            return self._callback\n\n        self._callback = get_callable(self._callback_str)\n        return self._callback\n\nclass RegexURLResolver(LocaleRegexProvider):\n    def __init__(self, regex, urlconf_name, default_kwargs=None, app_name=None, namespace=None):\n        LocaleRegexProvider.__init__(self, regex)\n        # urlconf_name is a string representing the module containing URLconfs.\n        self.urlconf_name = urlconf_name\n        if not isinstance(urlconf_name, six.string_types):\n            self._urlconf_module = self.urlconf_name\n        self.callback = None\n        self.default_kwargs = default_kwargs or {}\n        self.namespace = namespace\n        self.app_name = app_name\n        self._reverse_dict = {}\n        self._namespace_dict = {}\n        self._app_dict = {}\n\n    def __repr__(self):\n        if isinstance(self.urlconf_name, list) and len(self.urlconf_name):\n            # Don't bother to output the whole list, it can be huge\n            urlconf_repr = '<%s list>' % self.urlconf_name[0].__class__.__name__\n        else:\n            urlconf_repr = repr(self.urlconf_name)\n        return force_str('<%s %s (%s:%s) %s>' % (\n            self.__class__.__name__, urlconf_repr, self.app_name,\n            self.namespace, self.regex.pattern))\n\n    def _populate(self):\n        lookups = MultiValueDict()\n        namespaces = {}\n        apps = {}\n        language_code = get_language()\n        for pattern in reversed(self.url_patterns):\n            p_pattern = pattern.regex.pattern\n            if p_pattern.startswith('^'):\n                p_pattern = p_pattern[1:]\n            if isinstance(pattern, RegexURLResolver):\n                if pattern.namespace:\n                    namespaces[pattern.namespace] = (p_pattern, pattern)\n                    if pattern.app_name:\n                        apps.setdefault(pattern.app_name, []).append(pattern.namespace)\n                else:\n                    parent = normalize(pattern.regex.pattern)\n                    for name in pattern.reverse_dict:\n                        for matches, pat, defaults in pattern.reverse_dict.getlist(name):\n                            new_matches = []\n                            for piece, p_args in parent:\n                                new_matches.extend([(piece + suffix, p_args + args) for (suffix, args) in matches])\n                            lookups.appendlist(name, (new_matches, p_pattern + pat, dict(defaults, **pattern.default_kwargs)))\n                    for namespace, (prefix, sub_pattern) in pattern.namespace_dict.items():\n                        namespaces[namespace] = (p_pattern + prefix, sub_pattern)\n                    for app_name, namespace_list in pattern.app_dict.items():\n                        apps.setdefault(app_name, []).extend(namespace_list)\n            else:\n                bits = normalize(p_pattern)\n                lookups.appendlist(pattern.callback, (bits, p_pattern, pattern.default_args))\n                if pattern.name is not None:\n                    lookups.appendlist(pattern.name, (bits, p_pattern, pattern.default_args))\n        self._reverse_dict[language_code] = lookups\n        self._namespace_dict[language_code] = namespaces\n        self._app_dict[language_code] = apps\n\n    @property\n    def reverse_dict(self):\n        language_code = get_language()\n        if language_code not in self._reverse_dict:\n            self._populate()\n        return self._reverse_dict[language_code]\n\n    @property\n    def namespace_dict(self):\n        language_code = get_language()\n        if language_code not in self._namespace_dict:\n            self._populate()\n        return self._namespace_dict[language_code]\n\n    @property\n    def app_dict(self):\n        language_code = get_language()\n        if language_code not in self._app_dict:\n            self._populate()\n        return self._app_dict[language_code]\n\n    def resolve(self, path):\n        tried = []\n        match = self.regex.search(path)\n        if match:\n            new_path = path[match.end():]\n            for pattern in self.url_patterns:\n                try:\n                    sub_match = pattern.resolve(new_path)\n                except Resolver404 as e:\n                    sub_tried = e.args[0].get('tried')\n                    if sub_tried is not None:\n                        tried.extend([[pattern] + t for t in sub_tried])\n                    else:\n                        tried.append([pattern])\n                else:\n                    if sub_match:\n                        sub_match_dict = dict(match.groupdict(), **self.default_kwargs)\n                        sub_match_dict.update(sub_match.kwargs)\n                        return ResolverMatch(sub_match.func, sub_match.args, sub_match_dict, sub_match.url_name, self.app_name or sub_match.app_name, [self.namespace] + sub_match.namespaces)\n                    tried.append([pattern])\n            raise Resolver404({'tried': tried, 'path': new_path})\n        raise Resolver404({'path' : path})\n\n    @property\n    def urlconf_module(self):\n        try:\n            return self._urlconf_module\n        except AttributeError:\n            self._urlconf_module = import_module(self.urlconf_name)\n            return self._urlconf_module\n\n    @property\n    def url_patterns(self):\n        patterns = getattr(self.urlconf_module, \"urlpatterns\", self.urlconf_module)\n        try:\n            iter(patterns)\n        except TypeError:\n            raise ImproperlyConfigured(\"The included urlconf %s doesn't have any patterns in it\" % self.urlconf_name)\n        return patterns\n\n    def _resolve_special(self, view_type):\n        callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)\n        if not callback:\n            # No handler specified in file; use default\n            # Lazy import, since django.urls imports this file\n            from django.conf import urls\n            callback = getattr(urls, 'handler%s' % view_type)\n        return get_callable(callback), {}\n\n    def resolve403(self):\n        return self._resolve_special('403')\n\n    def resolve404(self):\n        return self._resolve_special('404')\n\n    def resolve500(self):\n        return self._resolve_special('500')\n\n    def reverse(self, lookup_view, *args, **kwargs):\n        return self._reverse_with_prefix(lookup_view, '', *args, **kwargs)\n\n    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):\n        if args and kwargs:\n            raise ValueError(\"Don't mix *args and **kwargs in call to reverse()!\")\n        try:\n            lookup_view = get_callable(lookup_view, True)\n        except (ImportError, AttributeError) as e:\n            raise NoReverseMatch(\"Error importing '%s': %s.\" % (lookup_view, e))\n        possibilities = self.reverse_dict.getlist(lookup_view)\n        prefix_norm, prefix_args = normalize(_prefix)[0]\n        for possibility, pattern, defaults in possibilities:\n            for result, params in possibility:\n                if args:\n                    if len(args) != len(params) + len(prefix_args):\n                        continue\n                    unicode_args = [force_text(val) for val in args]\n                    candidate =  (prefix_norm + result) % dict(zip(prefix_args + params, unicode_args))\n                else:\n                    if set(kwargs.keys()) | set(defaults.keys()) != set(params) | set(defaults.keys()) | set(prefix_args):\n                        continue\n                    matches = True\n                    for k, v in defaults.items():\n                        if kwargs.get(k, v) != v:\n                            matches = False\n                            break\n                    if not matches:\n                        continue\n                    unicode_kwargs = dict([(k, force_text(v)) for (k, v) in kwargs.items()])\n                    candidate = (prefix_norm + result) % unicode_kwargs\n                if re.search('^%s%s' % (_prefix, pattern), candidate, re.UNICODE):\n                    return candidate\n        # lookup_view can be URL label, or dotted path, or callable, Any of\n        # these can be passed in at the top, but callables are not friendly in\n        # error messages.\n        m = getattr(lookup_view, '__module__', None)\n        n = getattr(lookup_view, '__name__', None)\n        if m is not None and n is not None:\n            lookup_view_s = \"%s.%s\" % (m, n)\n        else:\n            lookup_view_s = lookup_view\n        raise NoReverseMatch(\"Reverse for '%s' with arguments '%s' and keyword \"\n                \"arguments '%s' not found.\" % (lookup_view_s, args, kwargs))\n\nclass LocaleRegexURLResolver(RegexURLResolver):\n    \"\"\"\n    A URL resolver that always matches the active language code as URL prefix.\n\n    Rather than taking a regex argument, we just override the ``regex``\n    function to always return the active language-code as regex.\n    \"\"\"\n    def __init__(self, urlconf_name, default_kwargs=None, app_name=None, namespace=None):\n        super(LocaleRegexURLResolver, self).__init__(\n            None, urlconf_name, default_kwargs, app_name, namespace)\n\n    @property\n    def regex(self):\n        language_code = get_language()\n        if language_code not in self._regex_dict:\n            regex_compiled = re.compile('^%s/' % language_code, re.UNICODE)\n            self._regex_dict[language_code] = regex_compiled\n        return self._regex_dict[language_code]\n\ndef resolve(path, urlconf=None):\n    if urlconf is None:\n        urlconf = get_urlconf()\n    return get_resolver(urlconf).resolve(path)\n\ndef reverse(viewname, urlconf=None, args=None, kwargs=None, prefix=None, current_app=None):\n    if urlconf is None:\n        urlconf = get_urlconf()\n    resolver = get_resolver(urlconf)\n    args = args or []\n    kwargs = kwargs or {}\n\n    if prefix is None:\n        prefix = get_script_prefix()\n\n    if not isinstance(viewname, six.string_types):\n        view = viewname\n    else:\n        parts = viewname.split(':')\n        parts.reverse()\n        view = parts[0]\n        path = parts[1:]\n\n        resolved_path = []\n        ns_pattern = ''\n        while path:\n            ns = path.pop()\n\n            # Lookup the name to see if it could be an app identifier\n            try:\n                app_list = resolver.app_dict[ns]\n                # Yes! Path part matches an app in the current Resolver\n                if current_app and current_app in app_list:\n                    # If we are reversing for a particular app,\n                    # use that namespace\n                    ns = current_app\n                elif ns not in app_list:\n                    # The name isn't shared by one of the instances\n                    # (i.e., the default) so just pick the first instance\n                    # as the default.\n                    ns = app_list[0]\n            except KeyError:\n                pass\n\n            try:\n                extra, resolver = resolver.namespace_dict[ns]\n                resolved_path.append(ns)\n                ns_pattern = ns_pattern + extra\n            except KeyError as key:\n                if resolved_path:\n                    raise NoReverseMatch(\n                        \"%s is not a registered namespace inside '%s'\" %\n                        (key, ':'.join(resolved_path)))\n                else:\n                    raise NoReverseMatch(\"%s is not a registered namespace\" %\n                                         key)\n        if ns_pattern:\n            resolver = get_ns_resolver(ns_pattern, resolver)\n\n    return iri_to_uri(resolver._reverse_with_prefix(view, prefix, *args, **kwargs))\n\nreverse_lazy = lazy(reverse, str)\n\ndef clear_url_caches():\n    global _resolver_cache\n    global _ns_resolver_cache\n    global _callable_cache\n    _resolver_cache.clear()\n    _ns_resolver_cache.clear()\n    _callable_cache.clear()\n\ndef set_script_prefix(prefix):\n    \"\"\"\n    Sets the script prefix for the current thread.\n    \"\"\"\n    if not prefix.endswith('/'):\n        prefix += '/'\n    _prefixes.value = prefix\n\ndef get_script_prefix():\n    \"\"\"\n    Returns the currently active script prefix. Useful for client code that\n    wishes to construct their own URLs manually (although accessing the request\n    instance is normally going to be a lot cleaner).\n    \"\"\"\n    return getattr(_prefixes, \"value\", '/')\n\ndef set_urlconf(urlconf_name):\n    \"\"\"\n    Sets the URLconf for the current thread (overriding the default one in\n    settings). Set to None to revert back to the default.\n    \"\"\"\n    if urlconf_name:\n        _urlconfs.value = urlconf_name\n    else:\n        if hasattr(_urlconfs, \"value\"):\n            del _urlconfs.value\n\ndef get_urlconf(default=None):\n    \"\"\"\n    Returns the root URLconf to use for the current thread if it has been\n    changed from the default one.\n    \"\"\"\n    return getattr(_urlconfs, \"value\", default)\n\ndef is_valid_path(path, urlconf=None):\n    \"\"\"\n    Returns True if the given path resolves against the default URL resolver,\n    False otherwise.\n\n    This is a convenience method to make working with \"is this a match?\" cases\n    easier, avoiding unnecessarily indented try...except blocks.\n    \"\"\"\n    try:\n        resolve(path, urlconf)\n        return True\n    except Resolver404:\n        return False"
}