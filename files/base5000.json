{
  "name": "form.inc.old",
  "timestamp": "2012-11-02T16:05:51Z",  
  "source": "<?php\n// $Id$\n\n/**\n * @defgroup forms Form builder functions\n * @{\n * Functions that build an abstract representation of a HTML form.\n *\n * All modules should declare their form builder functions to be in this\n * group and each builder function should reference its validate and submit\n * functions using \\@see. Conversely, validate and submit functions should\n * reference the form builder function using \\@see. For examples, of this see\n * system_modules_uninstall() or user_pass(), the latter of which has the\n * following in its doxygen documentation:\n *\n * \\@ingroup forms\n * \\@see user_pass_validate().\n * \\@see user_pass_submit().\n *\n * @} End of \"defgroup forms\".\n */\n\n/**\n * @defgroup form_api Form generation\n * @{\n * Functions to enable the processing and display of HTML forms.\n *\n * Drupal uses these functions to achieve consistency in its form processing and\n * presentation, while simplifying code and reducing the amount of HTML that\n * must be explicitly generated by modules.\n *\n * The primary function used with forms is drupal_get_form(), which is\n * used for forms presented interactively to a user. Forms can also be built and\n * submitted programmatically without any user input using the\n * drupal_form_submit() function.\n *\n * drupal_get_form() handles retrieving, processing, and displaying a rendered\n * HTML form for modules automatically.\n *\n * Here is an example of how to use drupal_get_form() and a form builder\n * function:\n * @code\n * $form = drupal_get_form('my_module_example_form');\n * ...\n * function my_module_example_form($form, &$form_state) {\n *   $form['submit'] = array(\n *     '#type' => 'submit',\n *     '#value' => t('Submit'),\n *   );\n *   return $form;\n * }\n * function my_module_example_form_validate($form, &$form_state) {\n *   // Validation logic.\n * }\n * function my_module_example_form_submit($form, &$form_state) {\n *   // Submission logic.\n * }\n * @endcode\n *\n * Or with any number of additional arguments:\n * @code\n * $extra = \"extra\";\n * $form = drupal_get_form('my_module_example_form', $extra);\n * ...\n * function my_module_example_form($form, &$form_state, $extra) {\n *   $form['submit'] = array(\n *     '#type' => 'submit',\n *     '#value' => $extra,\n *   );\n *   return $form;\n * }\n * @endcode\n *\n * The $form argument to form-related functions is a structured array containing\n * the elements and properties of the form. For information on the array\n * components and format, and more detailed explanations of the Form API\n * workflow, see the\n * @link http://api.drupal.org/api/drupal/developer--topics--forms_api_reference.html Form API reference @endlink\n * and the\n * @link http://drupal.org/node/37775 Form API section of the handbook. @endlink\n * In addition, there is a set of Form API tutorials in\n * @link form_example_tutorial.inc the Form Example Tutorial @endlink which\n * provide basics all the way up through multistep forms.\n *\n * In the form builder, validation, submission, and other form functions,\n * $form_state is the primary influence on the processing of the form and is\n * passed by reference to most functions, so they use it to communicate with\n * the form system and each other.\n *\n * The $form_state keys are:\n * - 'values': An associative array of values submitted to the form. The\n *   validation functions and submit functions use this array for nearly all\n *   their decision making. (Note that\n *   @link http://api.drupal.org/api/drupal/developer--topics--forms_api_reference.html/7#tree #tree @endlink\n *   determines whether the values are a flat array or an array whose structure\n *   parallels the $form array.)\n * - 'rebuild': If the submit function sets $form_state['rebuild'] to TRUE,\n *   submission is not completed and instead the form is rebuilt using any\n *   information that the submit function has made available to the form builder\n *   function via $form_state. This is commonly used for wizard-style\n *   multi-step forms, add-more buttons, and the like. For further information\n *   see drupal_build_form().\n * - 'redirect': a URL that will be used to redirect the form on submission.\n *   See drupal_redirect_form() for complete information.\n * - 'storage': $form_state['storage'] is not a special key, and no specific\n *   support is provided for it in the Form API, but by tradition it was\n *   the location where application-specific data was stored for communication\n *   between the submit, validation, and form builder functions, especially\n *   in a multi-step-style form. Form implementations may use any key(s) within\n *   $form_state (other than the keys listed here and other reserved ones used\n *   by Form API internals) for this kind of storage. The recommended way to\n *   ensure that the chosen key doesn't conflict with ones used by the Form API\n *   or other modules is to use the module name as the key name or a prefix for\n *   the key name. For example, the Node module uses $form_state['node'] in node\n *   editing forms to store information about the node being edited, and this\n *   information stays available across successive clicks of the \"Preview\"\n *   button as well as when the \"Save\" button is finally clicked.\n * - 'temporary': Since values for all non-reserved keys in $form_state persist\n *   throughout a multistep form sequence, the Form API provides the 'temporary'\n *   key for modules to use for communicating information across form-related\n *   functions during a single page request only. There is no use-case for this\n *   functionality in core.\n * - 'triggering_element': (read-only) The form element that triggered\n *   submission. This is the same as the deprecated\n *   $form_state['clicked_button']. It is the element that caused submission,\n *   which may or may not be a button (in the case of AJAX forms.) This is\n *   often used to distinguish between various buttons in a submit handler,\n *   and is also used in AJAX handlers.\n * - 'cache': The typical form workflow involves two page requests. During the\n *   first page request, a form is built and returned for the user to fill in.\n *   Then the user fills the form in and submits it, triggering a second page\n *   request in which the form must be built and processed. By default, $form\n *   and $form_state are built from scratch during each of these page requests.\n *   In some special use-cases, it is necessary or desired to persist the $form\n *   and $form_state variables from the initial page request to the one that\n *   processes the submission. A form builder function can set 'cache' to TRUE\n *   to do this. One example where this is needed is to handle AJAX submissions,\n *   so ajax_process_form() sets this for all forms that include an element with\n *   a #ajax property. (In AJAX, the handler has no way to build the form\n *   itself, so must rely on the cached version created on each page load, so\n *   it's a classic example of this use case.) Note that the persistence of\n *   $form and $form_state across successive submissions of a multi-step form\n *   happens automatically regardless of the value for 'cache'.\n * - 'input': The array of values as they were submitted by the user. These are\n *   raw and unvalidated, so should not be used without a thorough understanding\n *   of security implications. In almost all cases, code should use the data in\n *   the 'values' array exclusively. The most common use of this key is for\n *   multi-step forms that need to clear some of the user input when setting\n *   'rebuild'.\n */\n\n/**\n * Wrapper for drupal_build_form() for use when $form_state is not needed.\n *\n * @param $form_id\n *   The unique string identifying the desired form. If a function with that\n *   name exists, it is called to build the form array. Modules that need to\n *   generate the same form (or very similar forms) using different $form_ids\n *   can implement hook_forms(), which maps different $form_id values to the\n *   proper form constructor function. Examples may be found in node_forms(),\n *   search_forms(), and user_forms().\n * @param ...\n *   Any additional arguments are passed on to the functions called by\n *   drupal_get_form(), including the unique form constructor function. For\n *   example, the node_edit form requires that a node object is passed in here\n *   when it is called.\n *\n * @return\n *   The form array.\n *\n * @see drupal_build_form()\n */\nfunction drupal_get_form($form_id) {\n  $form_state = array();\n\n  $args = func_get_args();\n  // Remove $form_id from the arguments.\n  array_shift($args);\n  $form_state['build_info']['args'] = $args;\n\n  return drupal_build_form($form_id, $form_state);\n}\n\n/**\n * Build and process a form based on a form id.\n *\n * The form may also be retrieved from the cache if the form was built in a\n * previous page-load. The form is then passed on for processing, validation\n * and submission if there is proper input.\n *\n * @param $form_id\n *   The unique string identifying the desired form. If a function with that\n *   name exists, it is called to build the form array. Modules that need to\n *   generate the same form (or very similar forms) using different $form_ids\n *   can implement hook_forms(), which maps different $form_id values to the\n *   proper form constructor function. Examples may be found in node_forms(),\n *   search_forms(), and user_forms().\n * @param &$form_state\n *   An array which stores information about the form. This is passed as a\n *   reference so that the caller can use it to examine what in the form changed\n *   when the form submission process is complete. Furthermore, it may be used\n *   to store information related to the processed data in the form, which will\n *   persist across page requests when the 'cache' or 'rebuild' flag is set.\n *   The following parameters may be set in $form_state to affect how the form\n *   is rendered:\n *   - build_info: A keyed array of build information that is necessary to\n *     rebuild the form from cache when the original context may no longer be\n *     available:\n *     - args: An array of arguments to pass to the form builder.\n *     - files: An optional array defining include files that need to be loaded\n *       for building the form. Each array entry may be the path to a file or\n *       another array containing values for the parameters 'type', 'module' and\n *       'name' as needed by module_load_include(). The files listed here are\n *       automatically loaded by form_get_cache(). Defaults to the current menu\n *       router item's 'file' definition, if existent.\n *   - rebuild: Normally, after the entire form processing is completed and\n *     submit handlers ran, a form is considered to be done and\n *     drupal_redirect_form() will redirect the user to a new page using a GET\n *     request (so a browser refresh does not re-submit the form). However, if\n *     'rebuild' has been set to TRUE, then a new copy of the form is\n *     immediately built and sent to the browser; instead of a redirect. This is\n *     used for multi-step forms, such as wizards and confirmation forms.\n *     Normally, $form_state['rebuild'] is set by a submit handler, since it is\n *     usually logic within a submit handler that determines whether a form is\n *     done or requires another step. However, a validation handler may already\n *     set $form_state['rebuild'] to cause the form processing to bypass submit\n *     handlers and rebuild the form instead, even if there are no validation\n *     errors.\n *   - input: An array of input that corresponds to $_POST or $_GET, depending\n *     on the 'method' chosen (see below).\n *   - method: The HTTP form method to use for finding the input for this form.\n *     May be 'post' or 'get'. Defaults to 'post'. Note that 'get' method\n *     forms do not use form ids so are always considered to be submitted, which\n *     can have unexpected effects. The 'get' method should only be used on\n *     forms that do not change data, as that is exclusively the domain of post.\n *   - no_redirect: If set to TRUE the form will NOT perform a drupal_goto(),\n *     even if 'redirect' is set.\n *   - cache: If set to TRUE the original, unprocessed form structure will be\n *     cached, which allows to rebuild the entire form from cache.\n *   - no_cache: If set to TRUE the form will NOT be cached, even if 'cache' is\n *     set.\n *   - always_process: If TRUE and the method is GET, a form_id is not\n *     necessary. This should only be used on RESTful GET forms that do NOT\n *     write data, as this could lead to security issues. It is useful so that\n *     searches do not need to have a form_id in their query arguments to\n *     trigger the search.\n *   - must_validate: Ordinarily, a form is only validated once but there are\n *     times when a form is resubmitted internally and should be validated\n *     again. Setting this to TRUE will force that to happen. This is most\n *     likely to occur during AHAH or AJAX operations.\n *   - temporary: An array holding temporary data accessible during the current\n *     page request only. It may be used to temporary save any data that doesn't\n *     need to or shouldn't be cached during the whole form workflow, e.g. data\n *     that needs to be accessed during the current form build process only.\n *   - wrapper_callback: Modules that wish to pre-populate certain forms with\n *     common elements, such as back/next/save buttons in multi-step form\n *     wizards, may define a form builder function name that returns a form\n *     structure, which is passed on to the actual form builder function.\n *     Such implementations may either define the 'wrapper_callback' via\n *     hook_forms() or have to invoke drupal_build_form() (instead of\n *     drupal_get_form()) on their own in a custom menu callback to prepare\n *     $form_state accordingly.\n *   Further $form_state properties controlling the redirection behavior after\n *   form submission may be found in drupal_redirect_form().\n *\n * @return\n *   The rendered form or NULL, depending upon the $form_state flags that were set.\n *\n * @see drupal_redirect_form()\n */\nfunction drupal_build_form($form_id, &$form_state) {\n  // Ensure some defaults; if already set they will not be overridden.\n  $form_state += form_state_defaults();\n\n  if (!isset($form_state['input'])) {\n    $form_state['input'] = $form_state['method'] == 'get' ? $_GET : $_POST;\n  }\n\n  if (isset($_SESSION['batch_form_state'])) {\n    // We've been redirected here after a batch processing. The form has\n    // already been processed, but needs to be rebuilt. See _batch_finished().\n    $form_state = $_SESSION['batch_form_state'];\n    unset($_SESSION['batch_form_state']);\n    return drupal_rebuild_form($form_id, $form_state);\n  }\n\n  // If the incoming input contains a form_build_id, we'll check the cache for a\n  // copy of the form in question. If it's there, we don't have to rebuild the\n  // form to proceed. In addition, if there is stored form_state data from a\n  // previous step, we'll retrieve it so it can be passed on to the form\n  // processing code.\n  $check_cache = isset($form_state['input']['form_id']) && $form_state['input']['form_id'] == $form_id && !empty($form_state['input']['form_build_id']);\n  if ($check_cache) {\n    $form = form_get_cache($form_state['input']['form_build_id'], $form_state);\n  }\n\n  // If the previous bit of code didn't result in a populated $form object, we\n  // are hitting the form for the first time and we need to build it from\n  // scratch.\n  if (!isset($form)) {\n    // If we attempted to serve the form from cache, uncacheable $form_state\n    // keys need to be removed after retrieving and preparing the form, except\n    // any that were already set prior to retrieving the form.\n    if ($check_cache) {\n      $form_state_before_retrieval = $form_state;\n    }\n\n    $form = drupal_retrieve_form($form_id, $form_state);\n    drupal_prepare_form($form_id, $form, $form_state);\n\n    // form_set_cache() removes uncacheable $form_state keys defined in\n    // form_state_keys_no_cache() in order for multi-step forms to work\n    // properly. This means that form processing logic for single-step forms\n    // using $form_state['cache'] may depend on data stored in those keys\n    // during drupal_retrieve_form()/drupal_prepare_form(), but form\n    // processing should not depend on whether the form is cached or not, so\n    // $form_state is adjusted to match what it would be after a\n    // form_set_cache()/form_get_cache() sequence. These exceptions are\n    // allowed to survive here:\n    // - always_process: Does not make sense in conjunction with form caching\n    //   in the first place, since passing form_build_id as a GET parameter is\n    //   not desired.\n    // - temporary: Any assigned data is expected to survives within the same\n    //   page request.\n    if ($check_cache) {\n      $uncacheable_keys = array_flip(array_diff(form_state_keys_no_cache(), array('always_process', 'temporary')));\n      $form_state = array_diff_key($form_state, $uncacheable_keys);\n      $form_state += $form_state_before_retrieval;\n    }\n  }\n\n  // Now that we have a constructed form, process it. This is where:\n  // - Element #process functions get called to further refine $form.\n  // - User input, if any, gets incorporated in the #value property of the\n  //   corresponding elements and into $form_state['values'].\n  // - Validation and submission handlers are called.\n  // - If this submission is part of a multistep workflow, the form is rebuilt\n  //   to contain the information of the next step.\n  // - If necessary, the form and form state are cached or re-cached, so that\n  //   appropriate information persists to the next page request.\n  // All of the handlers in the pipeline receive $form_state by reference and\n  // can use it to know or update information about the state of the form.\n  drupal_process_form($form_id, $form, $form_state);\n\n  // If this was a successful submission of a single-step form or the last step\n  // of a multi-step form, then drupal_process_form() issued a redirect to\n  // another page, or back to this page, but as a new request. Therefore, if\n  // we're here, it means that this is either a form being viewed initially\n  // before any user input, or there was a validation error requiring the form\n  // to be re-displayed, or we're in a multi-step workflow and need to display\n  // the form's next step. In any case, we have what we need in $form, and can\n  // return it for rendering.\n  return $form;\n}\n\n/**\n * Retrieve default values for the $form_state array.\n */\nfunction form_state_defaults() {\n  return array(\n    'rebuild' => FALSE,\n    'rebuild_info' => array(),\n    'redirect' => NULL,\n    'build_info' => array('args' => array()),\n    'temporary' => array(),\n    'submitted' => FALSE,\n    'executed' => FALSE,\n    'programmed' => FALSE,\n    'cache'=> FALSE,\n    'method' => 'post',\n    'groups' => array(),\n    'buttons' => array(),\n  );\n}\n\n/**\n * Constructs a new $form from the information in $form_state.\n *\n * This is the key function for making multi-step forms advance from step to\n * step. It is called by drupal_process_form() when all user input processing,\n * including calling validation and submission handlers, for the request is\n * finished. If a validate or submit handler set $form_state['rebuild'] to TRUE,\n * and if other conditions don't preempt a rebuild from happening, then this\n * function is called to generate a new $form, the next step in the form\n * workflow, to be returned for rendering.\n *\n * AJAX form submissions are almost always multi-step workflows, so that is one\n * common use-case during which form rebuilding occurs. See ajax_form_callback()\n * for more information about creating AJAX-enabled forms.\n *\n * @param $form_id\n *   The unique string identifying the desired form. If a function\n *   with that name exists, it is called to build the form array.\n *   Modules that need to generate the same form (or very similar forms)\n *   using different $form_ids can implement hook_forms(), which maps\n *   different $form_id values to the proper form constructor function. Examples\n *   may be found in node_forms(), search_forms(), and user_forms().\n * @param $form_state\n *   A keyed array containing the current state of the form.\n * @param $old_form\n *   (optional) A previously built $form. Used to retain the #build_id and\n *   #action properties in AJAX callbacks and similar partial form rebuilds. The\n *   only properties copied from $old_form are the ones which both exist in\n *   $old_form and for which $form_state['rebuild_info']['copy'][PROPERTY] is\n *   TRUE. If $old_form is not passed, the entire $form is rebuilt freshly.\n *   'rebuild_info' needs to be a separate top-level property next to\n *   'build_info', since the contained data must not be cached.\n *\n * @return\n *   The newly built form.\n *\n * @see drupal_process_form()\n * @see ajax_form_callback()\n */\nfunction drupal_rebuild_form($form_id, &$form_state, $old_form = NULL) {\n  $form = drupal_retrieve_form($form_id, $form_state);\n\n  // If only parts of the form will be returned to the browser (e.g. AJAX or\n  // RIA clients), re-use the old #build_id to not require client-side code to\n  // manually update the hidden 'build_id' input element.\n  // Otherwise, a new #build_id is generated, to not clobber the previous\n  // build's data in the form cache; also allowing the user to go back to an\n  // earlier build, make changes, and re-submit.\n  // @see drupal_prepare_form()\n  if (isset($old_form['#build_id']) && !empty($form_state['rebuild_info']['copy']['#build_id'])) {\n    $form['#build_id'] = $old_form['#build_id'];\n  }\n  else {\n    $form['#build_id'] = 'form-' . drupal_hash_base64(uniqid(mt_rand(), TRUE) . mt_rand());\n  }\n\n  // #action defaults to request_uri(), but in case of AJAX and other partial\n  // rebuilds, the form is submitted to an alternate URL, and the original\n  // #action needs to be retained.\n  if (isset($old_form['#action']) && !empty($form_state['rebuild_info']['copy']['#action'])) {\n    $form['#action'] = $old_form['#action'];\n  }\n\n  drupal_prepare_form($form_id, $form, $form_state);\n\n  // Caching is normally done in drupal_process_form(), but what needs to be\n  // cached is the $form structure before it passes through form_builder(),\n  // so we need to do it here.\n  // @todo For Drupal 8, find a way to avoid this code duplication.\n  if (empty($form_state['no_cache'])) {\n    form_set_cache($form['#build_id'], $form, $form_state);\n  }\n\n  // Clear out all group associations as these might be different when\n  // re-rendering the form.\n  $form_state['groups'] = array();\n\n  // Return a fully built form that is ready for rendering.\n  return form_builder($form_id, $form, $form_state);\n}\n\n/**\n * Fetch a form from cache.\n */\nfunction form_get_cache($form_build_id, &$form_state) {\n  if ($cached = cache_get('form_' . $form_build_id, 'cache_form')) {\n    $form = $cached->data;\n\n    global $user;\n    if ((isset($form['#cache_token']) && drupal_valid_token($form['#cache_token'])) || (!isset($form['#cache_token']) && !$user->uid)) {\n      if ($cached = cache_get('form_state_' . $form_build_id, 'cache_form')) {\n        // Re-populate $form_state for subsequent rebuilds.\n        $form_state = $cached->data + $form_state;\n\n        // If the original form is contained in include files, load the files.\n        // See drupal_build_form().\n        $form_state['build_info'] += array('files' => array());\n        foreach ($form_state['build_info']['files'] as $file) {\n          if (is_array($file)) {\n            $file += array('type' => 'inc', 'name' => $file['module']);\n            module_load_include($file['type'], $file['module'], $file['name']);\n          }\n          elseif (file_exists($file)) {\n            require_once DRUPAL_ROOT . '/' . $file;\n          }\n        }\n      }\n      return $form;\n    }\n  }\n}\n\n/**\n * Store a form in the cache.\n */\nfunction form_set_cache($form_build_id, $form, $form_state) {\n  // 6 hours cache life time for forms should be plenty.\n  $expire = 21600;\n\n  // Cache form structure.\n  if (isset($form)) {\n    if ($GLOBALS['user']->uid) {\n      $form['#cache_token'] = drupal_get_token();\n    }\n    cache_set('form_' . $form_build_id, $form, 'cache_form', REQUEST_TIME + $expire);\n  }\n\n  // Cache form state.\n  if ($data = array_diff_key($form_state, array_flip(form_state_keys_no_cache()))) {\n    cache_set('form_state_' . $form_build_id, $data, 'cache_form', REQUEST_TIME + $expire);\n  }\n}\n\n/**\n * Returns an array of $form_state keys that shouldn't be cached.\n */\nfunction form_state_keys_no_cache() {\n  return array(\n    // Public properties defined by form constructors and form handlers.\n    'always_process',\n    'must_validate',\n    'rebuild',\n    'rebuild_info',\n    'redirect',\n    'no_redirect',\n    'temporary',\n    // Internal properties defined by form processing.\n    'buttons',\n    'triggering_element',\n    'clicked_button',\n    'complete form',\n    'groups',\n    'input',\n    'method',\n    'submit_handlers',\n    'submitted',\n    'executed',\n    'validate_handlers',\n    'values',\n  );\n}\n\n/**\n * Retrieves, populates, and processes a form.\n *\n * This function allows you to supply values for form elements and submit a\n * form for processing. Compare to drupal_get_form(), which also builds and\n * processes a form, but does not allow you to supply values.\n *\n * There is no return value, but you can check to see if there are errors\n * by calling form_get_errors().\n *\n * @param $form_id\n *   The unique string identifying the desired form. If a function\n *   with that name exists, it is called to build the form array.\n *   Modules that need to generate the same form (or very similar forms)\n *   using different $form_ids can implement hook_forms(), which maps\n *   different $form_id values to the proper form constructor function. Examples\n *   may be found in node_forms(), search_forms(), and user_forms().\n * @param $form_state\n *   A keyed array containing the current state of the form. Most important is\n *   the $form_state['values'] collection, a tree of data used to simulate the\n *   incoming $_POST information from a user's form submission. If a key is not\n *   filled in $form_state['values'], then the default value of the respective\n *   element is used. To submit an unchecked checkbox or other control that\n *   browsers submit by not having a $_POST entry, include the key, but set the\n *   value to NULL.\n * @param ...\n *   Any additional arguments are passed on to the functions called by\n *   drupal_form_submit(), including the unique form constructor function.\n *   For example, the node_edit form requires that a node object be passed\n *   in here when it is called. Arguments that need to be passed by reference\n *   should not be included here, but rather placed directly in the $form_state\n *   build info array so that the reference can be preserved. For example, a\n *   form builder function with the following signature:\n *   @code\n *   function mymodule_form($form, &$form_state, &$object) {\n *   }\n *   @endcode\n *   would be called via drupal_form_submit() as follows:\n *   @code\n *   $form_state['values'] = $my_form_values;\n *   $form_state['build_info']['args'] = array(&$object);\n *   drupal_form_submit('mymodule_form', $form_state);\n *   @endcode\n * For example:\n * @code\n * // register a new user\n * $form_state = array();\n * $form_state['values']['name'] = 'robo-user';\n * $form_state['values']['mail'] = 'robouser@example.com';\n * $form_state['values']['pass']['pass1'] = 'password';\n * $form_state['values']['pass']['pass2'] = 'password';\n * $form_state['values']['op'] = t('Create new account');\n * drupal_form_submit('user_register_form', $form_state);\n * @endcode\n */\nfunction drupal_form_submit($form_id, &$form_state) {\n  if (!isset($form_state['build_info']['args'])) {\n    $args = func_get_args();\n    array_shift($args);\n    array_shift($args);\n    $form_state['build_info']['args'] = $args;\n  }\n  // Merge in default values.\n  $form_state += form_state_defaults();\n\n  $form = drupal_retrieve_form($form_id, $form_state);\n  $form_state['input'] = $form_state['values'];\n  $form_state['programmed'] = TRUE;\n  // Programmed forms are always submitted.\n  $form_state['submitted'] = TRUE;\n\n  // Reset form validation.\n  $form_state['must_validate'] = TRUE;\n  form_clear_error();\n\n  drupal_prepare_form($form_id, $form, $form_state);\n  drupal_process_form($form_id, $form, $form_state);\n}\n\n/**\n * Retrieves the structured array that defines a given form.\n *\n * @param $form_id\n *   The unique string identifying the desired form. If a function\n *   with that name exists, it is called to build the form array.\n *   Modules that need to generate the same form (or very similar forms)\n *   using different $form_ids can implement hook_forms(), which maps\n *   different $form_id values to the proper form constructor function.\n * @param $form_state\n *   A keyed array containing the current state of the form, including the\n *   additional arguments to drupal_get_form() or drupal_form_submit() in the\n *   'args' component of the array.\n */\nfunction drupal_retrieve_form($form_id, &$form_state) {\n  $forms = &drupal_static(__FUNCTION__);\n\n  // Record the filepath of the include file containing the original form, so\n  // the form builder callbacks can be loaded when the form is being rebuilt\n  // from cache on a different path (such as 'system/ajax'). See\n  // form_get_cache().\n  // $menu_get_item() is not available at installation time.\n  if (!isset($form_state['build_info']['files']['menu']) && !defined('MAINTENANCE_MODE')) {\n    $item = menu_get_item();\n    if (!empty($item['include_file'])) {\n      $form_state['build_info']['files']['menu'] = $item['include_file'];\n    }\n  }\n\n  // We save two copies of the incoming arguments: one for modules to use\n  // when mapping form ids to constructor functions, and another to pass to\n  // the constructor function itself.\n  $args = $form_state['build_info']['args'];\n\n  // We first check to see if there's a function named after the $form_id.\n  // If there is, we simply pass the arguments on to it to get the form.\n  if (!function_exists($form_id)) {\n    // In cases where many form_ids need to share a central constructor function,\n    // such as the node editing form, modules can implement hook_forms(). It\n    // maps one or more form_ids to the correct constructor functions.\n    //\n    // We cache the results of that hook to save time, but that only works\n    // for modules that know all their form_ids in advance. (A module that\n    // adds a small 'rate this comment' form to each comment in a list\n    // would need a unique form_id for each one, for example.)\n    //\n    // So, we call the hook if $forms isn't yet populated, OR if it doesn't\n    // yet have an entry for the requested form_id.\n    if (!isset($forms) || !isset($forms[$form_id])) {\n      $forms = module_invoke_all('forms', $form_id, $args);\n    }\n    $form_definition = $forms[$form_id];\n    if (isset($form_definition['callback arguments'])) {\n      $args = array_merge($form_definition['callback arguments'], $args);\n    }\n    if (isset($form_definition['callback'])) {\n      $callback = $form_definition['callback'];\n      $form_state['build_info']['base_form_id'] = $callback;\n    }\n    // In case $form_state['wrapper_callback'] is not defined already, we also\n    // allow hook_forms() to define one.\n    if (!isset($form_state['wrapper_callback']) && isset($form_definition['wrapper_callback'])) {\n      $form_state['wrapper_callback'] = $form_definition['wrapper_callback'];\n    }\n  }\n\n  $form = array();\n  // We need to pass $form_state by reference in order for forms to modify it,\n  // since call_user_func_array() requires that referenced variables are passed\n  // explicitly.\n  $args = array_merge(array($form, &$form_state), $args);\n\n  // When the passed $form_state (not using drupal_get_form()) defines a\n  // 'wrapper_callback', then it requests to invoke a separate (wrapping) form\n  // builder function to pre-populate the $form array with form elements, which\n  // the actual form builder function ($callback) expects. This allows for\n  // pre-populating a form with common elements for certain forms, such as\n  // back/next/save buttons in multi-step form wizards. See drupal_build_form().\n  if (isset($form_state['wrapper_callback']) && function_exists($form_state['wrapper_callback'])) {\n    $form = call_user_func_array($form_state['wrapper_callback'], $args);\n    // Put the prepopulated $form into $args.\n    $args[0] = $form;\n  }\n\n  // If $callback was returned by a hook_forms() implementation, call it.\n  // Otherwise, call the function named after the form id.\n  $form = call_user_func_array(isset($callback) ? $callback : $form_id, $args);\n  $form['#form_id'] = $form_id;\n\n  return $form;\n}\n\n/**\n * Processes a form submission.\n *\n * This function is the heart of form API. The form gets built, validated and in\n * appropriate cases, submitted and rebuilt.\n *\n * @param $form_id\n *   The unique string identifying the current form.\n * @param $form\n *   An associative array containing the structure of the form.\n * @param $form_state\n *   A keyed array containing the current state of the form. This\n *   includes the current persistent storage data for the form, and\n *   any data passed along by earlier steps when displaying a\n *   multi-step form. Additional information, like the sanitized $_POST\n *   data, is also accumulated here.\n */\nfunction drupal_process_form($form_id, &$form, &$form_state) {\n  $form_state['values'] = array();\n\n  // With $_GET, these forms are always submitted if requested.\n  if ($form_state['method'] == 'get' && !empty($form_state['always_process'])) {\n    if (!isset($form_state['input']['form_build_id'])) {\n      $form_state['input']['form_build_id'] = $form['#build_id'];\n    }\n    if (!isset($form_state['input']['form_id'])) {\n      $form_state['input']['form_id'] = $form_id;\n    }\n    if (!isset($form_state['input']['form_token']) && isset($form['#token'])) {\n      $form_state['input']['form_token'] = drupal_get_token($form['#token']);\n    }\n  }\n\n  // form_builder() finishes building the form by calling element #process\n  // functions and mapping user input, if any, to #value properties, and also\n  // storing the values in $form_state['values']. We need to retain the\n  // unprocessed $form in case it needs to be cached.\n  $unprocessed_form = $form;\n  $form = form_builder($form_id, $form, $form_state);\n\n  // Only process the input if we have a correct form submission.\n  if ($form_state['process_input']) {\n    drupal_validate_form($form_id, $form, $form_state);\n\n    // drupal_html_id() maintains a cache of element IDs it has seen,\n    // so it can prevent duplicates. We want to be sure we reset that\n    // cache when a form is processed, so scenarios that result in\n    // the form being built behind the scenes and again for the\n    // browser don't increment all the element IDs needlessly.\n    drupal_static_reset('drupal_html_id');\n\n    if ($form_state['submitted'] && !form_get_errors() && !$form_state['rebuild']) {\n      // Execute form submit handlers.\n      form_execute_handlers('submit', $form, $form_state);\n\n      // We'll clear out the cached copies of the form and its stored data\n      // here, as we've finished with them. The in-memory copies are still\n      // here, though.\n      if (!variable_get('cache', 0) && !empty($form_state['values']['form_build_id'])) {\n        cache_clear_all('form_' . $form_state['values']['form_build_id'], 'cache_form');\n        cache_clear_all('form_state_' . $form_state['values']['form_build_id'], 'cache_form');\n      }\n\n      // If batches were set in the submit handlers, we process them now,\n      // possibly ending execution. We make sure we do not react to the batch\n      // that is already being processed (if a batch operation performs a\n      // drupal_form_submit).\n      if ($batch =& batch_get() && !isset($batch['current_set'])) {\n        // Store $form_state information in the batch definition.\n        // We need the full $form_state when either:\n        // - Some submit handlers were saved to be called during batch\n        //   processing. See form_execute_handlers().\n        // - The form is multistep.\n        // In other cases, we only need the information expected by\n        // drupal_redirect_form().\n        if ($batch['has_form_submits'] || !empty($form_state['rebuild'])) {\n          $batch['form_state'] = $form_state;\n        }\n        else {\n          $batch['form_state'] = array_intersect_key($form_state, array_flip(array('programmed', 'rebuild', 'storage', 'no_redirect', 'redirect')));\n        }\n\n        $batch['progressive'] = !$form_state['programmed'];\n        batch_process();\n\n        // Execution continues only for programmatic forms.\n        // For 'regular' forms, we get redirected to the batch processing\n        // page. Form redirection will be handled in _batch_finished(),\n        // after the batch is processed.\n      }\n\n      // Set a flag to indicate the the form has been processed and executed.\n      $form_state['executed'] = TRUE;\n\n      // Redirect the form based on values in $form_state.\n      drupal_redirect_form($form_state);\n    }\n\n    // Don't rebuild or cache form submissions invoked via drupal_form_submit().\n    if (!empty($form_state['programmed'])) {\n      return;\n    }\n\n    // If $form_state['rebuild'] has been set and input has been processed\n    // without validation errors, we are in a multi-step workflow that is not\n    // yet complete. A new $form needs to be constructed based on the changes\n    // made to $form_state during this request. Normally, a submit handler sets\n    // $form_state['rebuild'] if a fully executed form requires another step.\n    // However, for forms that have not been fully executed (e.g., AJAX\n    // submissions triggered by non-buttons), there is no submit handler to set\n    // $form_state['rebuild']. It would not make sense to redisplay the\n    // identical form without an error for the user to correct, so we also\n    // rebuild error-free non-executed forms, regardless of\n    // $form_state['rebuild'].\n    // @todo D8: Simplify this logic; considering AJAX and non-HTML front-ends,\n    //   along with element-level #submit properties, it makes no sense to have\n    //   divergent form execution based on whether the triggering element has\n    //   #executes_submit_callback set to TRUE.\n    if (($form_state['rebuild'] || !$form_state['executed']) && !form_get_errors()) {\n      // Form building functions (e.g., _form_builder_handle_input_element())\n      // may use $form_state['rebuild'] to determine if they are running in the\n      // context of a rebuild, so ensure it is set.\n      $form_state['rebuild'] = TRUE;\n      $form = drupal_rebuild_form($form_id, $form_state, $form);\n    }\n  }\n\n  // After processing the form, the form builder or a #process callback may\n  // have set $form_state['cache'] to indicate that the form and form state\n  // shall be cached. But the form may only be cached if the 'no_cache' property\n  // is not set to TRUE. Only cache $form as it was prior to form_builder(),\n  // because form_builder() must run for each request to accomodate new user\n  // input. Rebuilt forms are not cached here, because drupal_rebuild_form()\n  // already takes care of that.\n  if (!$form_state['rebuild'] && $form_state['cache'] && empty($form_state['no_cache'])) {\n    form_set_cache($form['#build_id'], $unprocessed_form, $form_state);\n  }\n}\n\n/**\n * Prepares a structured form array by adding required elements,\n * executing any hook_form_alter functions, and optionally inserting\n * a validation token to prevent tampering.\n *\n * @param $form_id\n *   A unique string identifying the form for validation, submission,\n *   theming, and hook_form_alter functions.\n * @param $form\n *   An associative array containing the structure of the form.\n * @param $form_state\n *   A keyed array containing the current state of the form. Passed\n *   in here so that hook_form_alter() calls can use it, as well.\n */\nfunction drupal_prepare_form($form_id, &$form, &$form_state) {\n  global $user;\n\n  $form['#type'] = 'form';\n  $form_state['programmed'] = isset($form_state['programmed']) ? $form_state['programmed'] : FALSE;\n\n  // Fix the form method, if it is 'get' in $form_state, but not in $form.\n  if ($form_state['method'] == 'get' && !isset($form['#method'])) {\n    $form['#method'] = 'get';\n  }\n\n  // Generate a new #build_id for this form, if none has been set already. The\n  // form_build_id is used as key to cache a particular build of the form. For\n  // multi-step forms, this allows the user to go back to an earlier build, make\n  // changes, and re-submit.\n  // @see drupal_build_form()\n  // @see drupal_rebuild_form()\n  if (!isset($form['#build_id'])) {\n    $form['#build_id'] = 'form-' . drupal_hash_base64(uniqid(mt_rand(), TRUE) . mt_rand());\n  }\n  $form['form_build_id'] = array(\n    '#type' => 'hidden',\n    '#value' => $form['#build_id'],\n    '#id' => $form['#build_id'],\n    '#name' => 'form_build_id',\n  );\n\n  // Add a token, based on either #token or form_id, to any form displayed to\n  // authenticated users. This ensures that any submitted form was actually\n  // requested previously by the user and protects against cross site request\n  // forgeries.\n  // This does not apply to programmatically submitted forms. Furthermore, since\n  // tokens are session-bound and forms displayed to anonymous users are very\n  // likely cached, we cannot assign a token for them.\n  // During installation, there is no $user yet.\n  if (!empty($user->uid) && !$form_state['programmed']) {\n    // Form constructors may explicitly set #token to FALSE when cross site\n    // request forgery is irrelevant to the form, such as search forms.\n    if (isset($form['#token']) && $form['#token'] === FALSE) {\n      unset($form['#token']);\n    }\n    // Otherwise, generate a public token based on the form id.\n    else {\n      $form['#token'] = $form_id;\n      $form['form_token'] = array(\n        '#id' => drupal_html_id('edit-' . $form_id . '-form-token'),\n        '#type' => 'token',\n        '#default_value' => drupal_get_token($form['#token']),\n      );\n    }\n  }\n\n  if (isset($form_id)) {\n    $form['form_id'] = array(\n      '#type' => 'hidden',\n      '#value' => $form_id,\n      '#id' => drupal_html_id(\"edit-$form_id\"),\n    );\n  }\n  if (!isset($form['#id'])) {\n    $form['#id'] = drupal_html_id($form_id);\n  }\n\n  $form += element_info('form');\n  $form += array('#tree' => FALSE, '#parents' => array());\n\n  if (!isset($form['#validate'])) {\n    // Check for a handler specific to $form_id.\n    if (function_exists($form_id . '_validate')) {\n      $form['#validate'][] = $form_id . '_validate';\n    }\n    // Otherwise check whether this is a shared form and whether there is a\n    // handler for the shared $form_id.\n    elseif (isset($form_state['build_info']['base_form_id']) && function_exists($form_state['build_info']['base_form_id'] . '_validate')) {\n      $form['#validate'][] = $form_state['build_info']['base_form_id'] . '_validate';\n    }\n  }\n\n  if (!isset($form['#submit'])) {\n    // Check for a handler specific to $form_id.\n    if (function_exists($form_id . '_submit')) {\n      $form['#submit'][] = $form_id . '_submit';\n    }\n    // Otherwise check whether this is a shared form and whether there is a\n    // handler for the shared $form_id.\n    elseif (isset($form_state['build_info']['base_form_id']) && function_exists($form_state['build_info']['base_form_id'] . '_submit')) {\n      $form['#submit'][] = $form_state['build_info']['base_form_id'] . '_submit';\n    }\n  }\n\n  // If no #theme has been set, automatically apply theme suggestions.\n  // theme_form() itself is in #theme_wrappers and not #theme. Therefore, the\n  // #theme function only has to care for rendering the inner form elements,\n  // not the form itself.\n  if (!isset($form['#theme'])) {\n    $form['#theme'] = array($form_id);\n    if (isset($form_state['build_info']['base_form_id'])) {\n      $form['#theme'][] = $form_state['build_info']['base_form_id'];\n    }\n  }\n\n  // Invoke hook_form_alter(), hook_form_BASE_FORM_ID_alter(), and\n  // hook_form_FORM_ID_alter() implementations.\n  $hooks = array('form');\n  if (isset($form_state['build_info']['base_form_id'])) {\n    $hooks[] = 'form_' . $form_state['build_info']['base_form_id'];\n  }\n  $hooks[] = 'form_' . $form_id;\n  drupal_alter($hooks, $form, $form_state, $form_id);\n}\n\n\n/**\n * Validates user-submitted form data from the $form_state using\n * the validate functions defined in a structured form array.\n *\n * @param $form_id\n *   A unique string identifying the form for validation, submission,\n *   theming, and hook_form_alter functions.\n * @param $form\n *   An associative array containing the structure of the form, which is passed\n *   by reference. Form validation handlers are able to alter the form structure\n *   (like #process and #after_build callbacks during form building) in case of\n *   a validation error. If a validation handler alters the form structure, it\n *   is responsible for validating the values of changed form elements in\n *   $form_state['values'] to prevent form submit handlers from receiving\n *   unvalidated values.\n * @param $form_state\n *   A keyed array containing the current state of the form. The current\n *   user-submitted data is stored in $form_state['values'], though\n *   form validation functions are passed an explicit copy of the\n *   values for the sake of simplicity. Validation handlers can also\n *   $form_state to pass information on to submit handlers. For example:\n *     $form_state['data_for_submission'] = $data;\n *   This technique is useful when validation requires file parsing,\n *   web service requests, or other expensive requests that should\n *   not be repeated in the submission step.\n */\nfunction drupal_validate_form($form_id, &$form, &$form_state) {\n  $validated_forms = &drupal_static(__FUNCTION__, array());\n\n  if (isset($validated_forms[$form_id]) && empty($form_state['must_validate'])) {\n    return;\n  }\n\n  // If the session token was set by drupal_prepare_form(), ensure that it\n  // matches the current user's session.\n  if (isset($form['#token'])) {\n    if (!drupal_valid_token($form_state['values']['form_token'], $form['#token'])) {\n      // Setting this error will cause the form to fail validation.\n      form_set_error('form_token', t('This form is outdated. Reload the page and try again. Contact the site administrator if the problem persists.'));\n    }\n  }\n\n  _form_validate($form, $form_state, $form_id);\n  $validated_forms[$form_id] = TRUE;\n\n  // If validation errors are limited then remove any non validated form values,\n  // so that only values that passed validation are left for submit callbacks.\n  if (isset($form_state['triggering_element']['#limit_validation_errors']) && $form_state['triggering_element']['#limit_validation_errors'] !== FALSE) {\n    $values = array();\n    foreach ($form_state['triggering_element']['#limit_validation_errors'] as $section) {\n      // If the section exists within $form_state['values'], even if the value\n      // is NULL, copy it to $values.\n      $section_exists = NULL;\n      $value = drupal_array_get_nested_value($form_state['values'], $section, $section_exists);\n      if ($section_exists) {\n        drupal_array_set_nested_value($values, $section, $value);\n      }\n    }\n    // For convenience we always make the value of the pressed button available.\n    if (isset($form_state['triggering_element']['#button_type'])) {\n      $values[$form_state['triggering_element']['#name']] = $form_state['triggering_element']['#value'];\n      drupal_array_set_nested_value($values, $form_state['triggering_element']['#parents'], $form_state['triggering_element']['#value']);\n    }\n    $form_state['values'] = $values;\n  }\n}\n\n/**\n * Redirects the user to a URL after a form has been processed.\n *\n * After a form was executed, the data in $form_state controls whether the form\n * is redirected. By default, we redirect to a new destination page. The path of\n * the destination page can be set in $form_state['redirect']. If that is not\n * set, the user is redirected to the current page to display a fresh,\n * unpopulated copy of the form.\n *\n * There are several triggers that may prevent a redirection though:\n * - If $form_state['redirect'] is FALSE, a form builder function or form\n *   validation/submit handler does not want a user to be redirected, which\n *   means that drupal_goto() is not invoked. For most forms, the redirection\n *   logic will be the same regardless of whether $form_state['redirect'] is\n *   undefined or FALSE. However, in case it was not defined and the current\n *   request contains a 'destination' query string, drupal_goto() will redirect\n *   to that given destination instead. Only setting $form_state['redirect'] to\n *   FALSE will prevent any redirection.\n * - If $form_state['no_redirect'] is TRUE, then the callback that originally\n *   built the form explicitly disallows any redirection, regardless of the\n *   redirection value in $form_state['redirect']. For example, ajax_get_form()\n *   defines $form_state['no_redirect'] when building a form in an AJAX\n *   callback to prevent any redirection. $form_state['no_redirect'] should NOT\n *   be altered by form builder functions or form validation/submit handlers.\n * - If $form_state['programmed'] is TRUE, the form submission was usually\n *   invoked via drupal_form_submit(), so any redirection would break the script\n *   that invoked drupal_form_submit().\n * - If $form_state['rebuild'] is TRUE, the form needs to be rebuilt without\n *   redirection.\n *\n * @param $form_state\n *   A keyed array containing the current state of the form.\n *\n * @see drupal_process_form()\n * @see drupal_build_form()\n */\nfunction drupal_redirect_form($form_state) {\n  // Skip redirection for form submissions invoked via drupal_form_submit().\n  if (!empty($form_state['programmed'])) {\n    return;\n  }\n  // Skip redirection if rebuild is activated.\n  if (!empty($form_state['rebuild'])) {\n    return;\n  }\n  // Skip redirection if it was explicitly disallowed.\n  if (!empty($form_state['no_redirect'])) {\n    return;\n  }\n  // Only invoke drupal_goto() if redirect value was not set to FALSE.\n  if (!isset($form_state['redirect']) || $form_state['redirect'] !== FALSE) {\n    if (isset($form_state['redirect'])) {\n      if (is_array($form_state['redirect'])) {\n        call_user_func_array('drupal_goto', $form_state['redirect']);\n      }\n      else {\n        // This function can be called from the installer, which guarantees\n        // that $redirect will always be a string, so catch that case here\n        // and use the appropriate redirect function.\n        $function = drupal_installation_attempted() ? 'install_goto' : 'drupal_goto';\n        $function($form_state['redirect']);\n      }\n    }\n    drupal_goto($_GET['q']);\n  }\n}\n\n/**\n * Performs validation on form elements. First ensures required fields are\n * completed, #maxlength is not exceeded, and selected options were in the\n * list of options given to the user. Then calls user-defined validators.\n *\n * @param $elements\n *   An associative array containing the structure of the form.\n * @param $form_state\n *   A keyed array containing the current state of the form. The current\n *   user-submitted data is stored in $form_state['values'], though\n *   form validation functions are passed an explicit copy of the\n *   values for the sake of simplicity. Validation handlers can also\n *   $form_state to pass information on to submit handlers. For example:\n *     $form_state['data_for_submission'] = $data;\n *   This technique is useful when validation requires file parsing,\n *   web service requests, or other expensive requests that should\n *   not be repeated in the submission step.\n * @param $form_id\n *   A unique string identifying the form for validation, submission,\n *   theming, and hook_form_alter functions.\n */\nfunction _form_validate(&$elements, &$form_state, $form_id = NULL) {\n  // Also used in the installer, pre-database setup.\n  $t = get_t();\n\n  // Recurse through all children.\n  foreach (element_children($elements) as $key) {\n    if (isset($elements[$key]) && $elements[$key]) {\n      _form_validate($elements[$key], $form_state);\n    }\n  }\n\n  // Validate the current input.\n  if (!isset($elements['#validated']) || !$elements['#validated']) {\n    // The following errors are always shown.\n    if (isset($elements['#needs_validation'])) {\n      // Verify that the value is not longer than #maxlength.\n      if (isset($elements['#maxlength']) && drupal_strlen($elements['#value']) > $elements['#maxlength']) {\n        form_error($elements, $t('!name cannot be longer than %max characters but is currently %length characters long.', array('!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title'], '%max' => $elements['#maxlength'], '%length' => drupal_strlen($elements['#value']))));\n      }\n\n      if (isset($elements['#options']) && isset($elements['#value'])) {\n        if ($elements['#type'] == 'select') {\n          $options = form_options_flatten($elements['#options']);\n        }\n        else {\n          $options = $elements['#options'];\n        }\n        if (is_array($elements['#value'])) {\n          $value = $elements['#type'] == 'checkboxes' ? array_keys($elements['#value']) : $elements['#value'];\n          foreach ($value as $v) {\n            if (!isset($options[$v])) {\n              form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));\n              watchdog('form', 'Illegal choice %choice in !name element.', array('%choice' => $v, '!name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);\n            }\n          }\n        }\n        // Non-multiple select fields always have a value in HTML. If the user\n        // does not change the form, it will be the value of the first option.\n        // Because of this, form validation for the field will almost always\n        // pass, even if the user did not select anything. To work around this\n        // browser behavior, required select fields without a #default_value get\n        // an additional, first empty option. In case the submitted value is\n        // identical to the empty option's value, we reset the element's value\n        // to NULL to trigger the regular #required handling below.\n        // @see form_process_select()\n        elseif ($elements['#type'] == 'select' && !$elements['#multiple'] && $elements['#required'] && !isset($elements['#default_value']) && $elements['#value'] === $elements['#empty_value']) {\n          $elements['#value'] = NULL;\n          form_set_value($elements, NULL, $form_state);\n        }\n        elseif (!isset($options[$elements['#value']])) {\n          form_error($elements, $t('An illegal choice has been detected. Please contact the site administrator.'));\n          watchdog('form', 'Illegal choice %choice in %name element.', array('%choice' => $elements['#value'], '%name' => empty($elements['#title']) ? $elements['#parents'][0] : $elements['#title']), WATCHDOG_ERROR);\n        }\n      }\n    }\n\n    // While this element is being validated, it may be desired that some calls\n    // to form_set_error() be suppressed and not result in a form error, so\n    // that a button that implements low-risk functionality (such as \"Previous\"\n    // or \"Add more\") that doesn't require all user input to be valid can still\n    // have its submit handlers triggered. The triggering element's\n    // #limit_validation_errors property contains the information for which\n    // errors are needed, and all other errors are to be suppressed. The\n    // #limit_validation_errors property is ignored if submit handlers will run,\n    // but the element doesn't have a #submit property, because it's too large a\n    // security risk to have any invalid user input when executing form-level\n    // submit handlers.\n    if (isset($form_state['triggering_element']['#limit_validation_errors']) && ($form_state['triggering_element']['#limit_validation_errors'] !== FALSE) && !($form_state['submitted'] && !isset($form_state['triggering_element']['#submit']))) {\n      form_set_error(NULL, '', $form_state['triggering_element']['#limit_validation_errors']);\n    }\n    // If submit handlers won't run (due to the submission having been triggered\n    // by an element whose #executes_submit_callback property isn't TRUE), then\n    // it's safe to suppress all validation errors, and we do so by default,\n    // which is particularly useful during an AJAX submission triggered by a\n    // non-button. An element can override this default by setting the\n    // #limit_validation_errors property. For button element types,\n    // #limit_validation_errors defaults to FALSE (via system_element_info()),\n    // so that full validation is their default behavior.\n    elseif (isset($form_state['triggering_element']) && !isset($form_state['triggering_element']['#limit_validation_errors']) && !$form_state['submitted']) {\n      form_set_error(NULL, '', array());\n    }\n    // As an extra security measure, explicitly turn off error suppression if\n    // one of the above conditions wasn't met. Since this is also done at the\n    // end of this function, doing it here is only to handle the rare edge case\n    // where a validate handler invokes form processing of another form.\n    else {\n      drupal_static_reset('form_set_error:limit_validation_errors');\n    }\n\n    // Make sure a value is passed when the field is required.\n    if (isset($elements['#needs_validation']) && $elements['#required']) {\n      // A simple call to empty() will not cut it here as some fields, like\n      // checkboxes, can return a valid value of '0'. Instead, check the\n      // length if it's a string, and the item count if it's an array.\n      // An unchecked checkbox has a #value of integer 0, different than string\n      // '0', which could be a valid value.\n      $is_empty_multiple = (!count($elements['#value']));\n      $is_empty_string = (is_string($elements['#value']) && drupal_strlen(trim($elements['#value'])) == 0);\n      $is_empty_value = ($elements['#value'] === 0);\n      if ($is_empty_multiple || $is_empty_string || $is_empty_value) {\n        // Although discouraged, a #title is not mandatory for form elements. In\n        // case there is no #title, we cannot set a form error message.\n        // Instead of setting no #title, form constructors are encouraged to set\n        // #title_display to 'invisible' to improve accessibility.\n        if (isset($elements['#title'])) {\n          form_error($elements, $t('!name field is required.', array('!name' => $elements['#title'])));\n        }\n        else {\n          form_error($elements);\n        }\n      }\n    }\n\n    // Call user-defined form level validators.\n    if (isset($form_id)) {\n      form_execute_handlers('validate', $elements, $form_state);\n    }\n    // Call any element-specific validators. These must act on the element\n    // #value data.\n    elseif (isset($elements['#element_validate'])) {\n      foreach ($elements['#element_validate'] as $function) {\n        $function($elements, $form_state, $form_state['complete form']);\n      }\n    }\n    $elements['#validated'] = TRUE;\n  }\n\n  // Done validating this element, so turn off error suppression.\n  // _form_validate() turns it on again when starting on the next element, if\n  // it's still appropriate to do so.\n  drupal_static_reset('form_set_error:limit_validation_errors');\n}\n\n/**\n * A helper function used to execute custom validation and submission\n * handlers for a given form. Button-specific handlers are checked\n * first. If none exist, the function falls back to form-level handlers.\n *\n * @param $type\n *   The type of handler to execute. 'validate' or 'submit' are the\n *   defaults used by Form API.\n * @param $form\n *   An associative array containing the structure of the form.\n * @param $form_state\n *   A keyed array containing the current state of the form. If the user\n *   submitted the form by clicking a button with custom handler functions\n *   defined, those handlers will be stored here.\n */\nfunction form_execute_handlers($type, &$form, &$form_state) {\n  $return = FALSE;\n  // If there was a button pressed, use its handlers.\n  if (isset($form_state[$type . '_handlers'])) {\n    $handlers = $form_state[$type . '_handlers'];\n  }\n  // Otherwise, check for a form-level handler.\n  elseif (isset($form['#' . $type])) {\n    $handlers = $form['#' . $type];\n  }\n  else {\n    $handlers = array();\n  }\n\n  foreach ($handlers as $function) {\n    // Check if a previous _submit handler has set a batch, but make sure we\n    // do not react to a batch that is already being processed (for instance\n    // if a batch operation performs a drupal_form_submit()).\n    if ($type == 'submit' && ($batch =& batch_get()) && !isset($batch['id'])) {\n      // Some previous submit handler has set a batch. To ensure correct\n      // execution order, store the call in a special 'control' batch set.\n      // See _batch_next_set().\n      $batch['sets'][] = array('form_submit' => $function);\n      $batch['has_form_submits'] = TRUE;\n    }\n    else {\n      $function($form, $form_state);\n    }\n    $return = TRUE;\n  }\n  return $return;\n}\n\n/**\n * Files an error against a form element.\n *\n * When a validation error is detected, the validator calls form_set_error() to\n * indicate which element needs to be changed and provide an error message. This\n * causes the Form API to not execute the form submit handlers, and instead to\n * re-display the form to the user with the corresponding elements rendered with\n * an 'error' CSS class (shown as red by default).\n *\n * The standard form_set_error() behavior can be changed if a button provides\n * the #limit_validation_errors property. Multistep forms not wanting to\n * validate the whole form can set #limit_validation_errors on buttons to\n * limit validation errors to only certain elements. For example, pressing the\n * \"Previous\" button in a multistep form should not fire validation errors just\n * because the current step has invalid values. If #limit_validation_errors is\n * set on a clicked button, the button must also define a #submit property\n * (may be set to an empty array). Any #submit handlers will be executed even if\n * there is invalid input, so extreme care should be taken with respect to any\n * actions taken by them. This is typically not a problem with buttons like\n * \"Previous\" or \"Add more\" that do not invoke persistent storage of the\n * submitted form values. Do not use the #limit_validation_errors property on\n * buttons that trigger saving of form values to the database.\n *\n * The #limit_validation_errors property is a list of \"sections\" within\n * $form_state['values'] that must contain valid values. Each \"section\" is an\n * array with the ordered set of keys needed to reach that part of\n * $form_state['values'] (i.e., the #parents property of the element).\n *\n * Example 1: Allow the \"Previous\" button to function, regardless of whether any\n * user input is valid.\n *\n * @code\n *   $form['actions']['previous'] = array(\n *     '#type' => 'submit',\n *     '#value' => t('Previous'),\n *     '#limit_validation_errors' => array(),       // No validation.\n *     '#submit' => array('some_submit_function'),  // #submit required.\n *   );\n * @endcode\n *\n * Example 2: Require some, but not all, user input to be valid to process the\n * submission of a \"Previous\" button.\n *\n * @code\n *   $form['actions']['previous'] = array(\n *     '#type' => 'submit',\n *     '#value' => t('Previous'),\n *     '#limit_validation_errors' => array(\n *       array('step1'),       // Validate $form_state['values']['step1'].\n *       array('foo', 'bar'),  // Validate $form_state['values']['foo']['bar'].\n *     ),\n *     '#submit' => array('some_submit_function'), // #submit required.\n *   );\n * @endcode\n *\n * This will require $form_state['values']['step1'] and everything within it\n * (for example, $form_state['values']['step1']['choice']) to be valid, so\n * calls to form_set_error('step1', $message) or\n * form_set_error('step1][choice', $message) will prevent the submit handlers\n * from running, and result in the error message being displayed to the user.\n * However, calls to form_set_error('step2', $message) and\n * form_set_error('step2][groupX][choiceY', $message) will be suppressed,\n * resulting in the message not being displayed to the user, and the submit\n * handlers will run despite $form_state['values']['step2'] and\n * $form_state['values']['step2']['groupX']['choiceY'] containing invalid\n * values. Errors for an invalid $form_state['values']['foo'] will be\n * suppressed, but errors flagging invalid values for\n * $form_state['values']['foo']['bar'] and everything within it will be\n * flagged and submission prevented.\n *\n * Partial form validation is implemented by suppressing errors rather than by\n * skipping the input processing and validation steps entirely, because some\n * forms have button-level submit handlers that call Drupal API functions that\n * assume that certain data exists within $form_state['values'], and while not\n * doing anything with that data that requires it to be valid, PHP errors\n * would be triggered if the input processing and validation steps were fully\n * skipped.\n * @see http://drupal.org/node/370537\n * @see http://drupal.org/node/763376\n *\n * @param $name\n *   The name of the form element. If the #parents property of your form\n *   element is array('foo', 'bar', 'baz') then you may set an error on 'foo'\n *   or 'foo][bar][baz'. Setting an error on 'foo' sets an error for every\n *   element where the #parents array starts with 'foo'.\n * @param $message\n *   The error message to present to the user.\n * @param $limit_validation_errors\n *   Internal use only. The #limit_validation_errors property of the clicked\n *   button, if it exists.\n *\n * @return\n *   Return value is for internal use only. To get a list of errors, use\n *   form_get_errors() or form_get_error().\n */\nfunction form_set_error($name = NULL, $message = '', $limit_validation_errors = NULL) {\n  $form = &drupal_static(__FUNCTION__, array());\n  $sections = &drupal_static(__FUNCTION__ . ':limit_validation_errors');\n  if (isset($limit_validation_errors)) {\n    $sections = $limit_validation_errors;\n  }\n\n  if (isset($name) && !isset($form[$name])) {\n    $record = TRUE;\n    if (isset($sections)) {\n      // #limit_validation_errors is an array of \"sections\" within which user\n      // input must be valid. If the element is within one of these sections,\n      // the error must be recorded. Otherwise, it can be suppressed.\n      // #limit_validation_errors can be an empty array, in which case all\n      // errors are suppressed. For example, a \"Previous\" button might want its\n      // submit action to be triggered even if none of the submitted values are\n      // valid.\n      $record = FALSE;\n      foreach ($sections as $section) {\n        // Exploding by '][' reconstructs the element's #parents. If the\n        // reconstructed #parents begin with the same keys as the specified\n        // section, then the element's values are within the part of\n        // $form_state['values'] that the clicked button requires to be valid,\n        // so errors for this element must be recorded.\n        if (array_slice(explode('][', $name), 0, count($section)) === $section) {\n          $record = TRUE;\n          break;\n        }\n      }\n    }\n    if ($record) {\n      $form[$name] = $message;\n      if ($message) {\n        drupal_set_message($message, 'error');\n      }\n    }\n  }\n\n  return $form;\n}\n\n/**\n * Clear all errors against all form elements made by form_set_error().\n */\nfunction form_clear_error() {\n  drupal_static_reset('form_set_error');\n}\n\n/**\n * Return an associative array of all errors.\n */\nfunction form_get_errors() {\n  $form = form_set_error();\n  if (!empty($form)) {\n    return $form;\n  }\n}\n\n/**\n * Returns the error message filed against the given form element.\n *\n * Form errors higher up in the form structure override deeper errors as well as\n * errors on the element itself.\n */\nfunction form_get_error($element) {\n  $form = form_set_error();\n  $parents = array();\n  foreach ($element['#parents'] as $parent) {\n    $parents[] = $parent;\n    $key = implode('][', $parents);\n    if (isset($form[$key])) {\n      return $form[$key];\n    }\n  }\n}\n\n/**\n * Flag an element as having an error.\n */\nfunction form_error(&$element, $message = '') {\n  form_set_error(implode('][', $element['#parents']), $message);\n}\n\n/**\n * Walk through the structured form array, adding any required properties to\n * each element and mapping the incoming input data to the proper elements.\n * Also, execute any #process handlers attached to a specific element.\n *\n * This is one of the three primary functions that recursively iterates a form\n * array. This one does it for completing the form building process. The other\n * two are _form_validate() (invoked via drupal_validate_form() and used to\n * invoke validation logic for each element) and drupal_render() (for rendering\n * each element). Each of these three pipelines provides ample opportunity for\n * modules to customize what happens. For example, during this function's life\n * cycle, the following functions get called for each element:\n * - $element['#value_callback']: A function that implements how user input is\n *   mapped to an element's #value property. This defaults to a function named\n *   'form_type_TYPE_value' where TYPE is $element['#type'].\n * - $element['#process']: An array of functions called after user input has\n *   been mapped to the element's #value property. These functions can be used\n *   to dynamically add child elements: for example, for the 'date' element\n *   type, one of the functions in this array is form_process_date(), which adds\n *   the individual 'year', 'month', 'day', etc. child elements. These functions\n *   can also be used to set additional properties or implement special logic\n *   other than adding child elements: for example, for the 'fieldset' element\n *   type, one of the functions in this array is form_process_fieldset(), which\n *   adds the attributes and JavaScript needed to make the fieldset collapsible\n *   if the #collapsible property is set. The #process functions are called in\n *   preorder traversal, meaning they are called for the parent element first,\n *   then for the child elements.\n * - $element['#after_build']: An array of functions called after form_builder()\n *   is done with its processing of the element. These are called in postorder\n *   traversal, meaning they are called for the child elements first, then for\n *   the parent element.\n * There are similar properties containing callback functions invoked by\n * _form_validate() and drupal_render(), appropriate for those operations.\n *\n * Developers are strongly encouraged to integrate the functionality needed by\n * their form or module within one of these three pipelines, using the\n * appropriate callback property, rather than implementing their own recursive\n * traversal of a form array. This facilitates proper integration between\n * multiple modules. For example, module developers are familiar with the\n * relative order in which hook_form_alter() implementations and #process\n * functions run. A custom traversal function that affects the building of a\n * form is likely to not integrate with hook_form_alter() and #process in the\n * expected way. Also, deep recursion within PHP is both slow and memory\n * intensive, so it is best to minimize how often it's done.\n *\n * As stated above, each element's #process functions are executed after its\n * #value has been set. This enables those functions to execute conditional\n * logic based on the current value. However, all of form_builder() runs before\n * drupal_validate_form() is called, so during #process function execution, the\n * element's #value has not yet been validated, so any code that requires\n * validated values must reside within a submit handler.\n *\n * As a security measure, user input is used for an element's #value only if the\n * element exists within $form, is not disabled (as per the #disabled property),\n * and can be accessed (as per the #access property, except that forms submitted\n * using drupal_form_submit() bypass #access restrictions). When user input is\n * ignored due to #disabled and #access restrictions, the element's default\n * value is used.\n *\n * Because of the preorder traversal, where #process functions of an element run\n * before user input for its child elements is processed, and because of the\n * Form API security of user input processing with respect to #access and\n * #disabled described above, this generally means that #process functions\n * should not use an element's (unvalidated) #value to affect the #disabled or\n * #access of child elements. Use-cases where a developer may be tempted to\n * implement such conditional logic usually fall into one of two categories:\n * - Where user input from the current submission must affect the structure of a\n *   form, including properties like #access and #disabled that affect how the\n *   next submission needs to be processed, a multi-step workflow is needed.\n *   This is most commonly implemented with a submit handler setting persistent\n *   data within $form_state based on *validated* values in\n *   $form_state['values'] and setting $form_state['rebuild']. The form building\n *   functions must then be implmented to use the $form_state data to rebuild\n *   the form with the structure appropriate for the new state.\n * - Where user input must affect the rendering of the form without affecting\n *   its structure, the necessary conditional rendering logic should reside\n *   within functions that run during the rendering phase (#pre_render, #theme,\n *   #theme_wrappers, and #post_render).\n *\n * @param $form_id\n *   A unique string identifying the form for validation, submission,\n *   theming, and hook_form_alter functions.\n * @param $element\n *   An associative array containing the structure of the current element.\n * @param $form_state\n *   A keyed array containing the current state of the form. In this\n *   context, it is used to accumulate information about which button\n *   was clicked when the form was submitted, as well as the sanitized\n *   $_POST data.\n */\nfunction form_builder($form_id, $element, &$form_state) {\n  // Initialize as unprocessed.\n  $element['#processed'] = FALSE;\n\n  // Use element defaults.\n  if (isset($element['#type']) && empty($element['#defaults_loaded']) && ($info = element_info($element['#type']))) {\n    // Overlay $info onto $element, retaining preexisting keys in $element.\n    $element += $info;\n    $element['#defaults_loaded'] = TRUE;\n  }\n  // Assign basic defaults common for all form elements.\n  $element += array(\n    '#required' => FALSE,\n    '#attributes' => array(),\n    '#title_display' => 'before',\n  );\n\n  // Special handling if we're on the top level form element.\n  if (isset($element['#type']) && $element['#type'] == 'form') {\n    if (!empty($element['#https']) && variable_get('https', FALSE) &&\n        !url_is_external($element['#action'])) {\n      global $base_root;\n\n      // Not an external URL so ensure that it is secure.\n      $element['#action'] = str_replace('http://', 'https://', $base_root) . $element['#action'];\n    }\n\n    // Store a complete copy of the form in form_state prior to building the form.\n    $form_state['complete form'] = $element;\n    // Set a flag if we have a correct form submission. This is always TRUE for\n    // programmed forms coming from drupal_form_submit(), or if the form_id coming\n    // from the POST data is set and matches the current form_id.\n    if ($form_state['programmed'] || (!empty($form_state['input']) && (isset($form_state['input']['form_id']) && ($form_state['input']['form_id'] == $form_id)))) {\n      $form_state['process_input'] = TRUE;\n    }\n    else {\n      $form_state['process_input'] = FALSE;\n    }\n  }\n\n  if (!isset($element['#id'])) {\n    $element['#id'] = drupal_html_id('edit-' . implode('-', $element['#parents']));\n  }\n  // Handle input elements.\n  if (!empty($element['#input'])) {\n    _form_builder_handle_input_element($form_id, $element, $form_state);\n  }\n  // Allow for elements to expand to multiple elements, e.g., radios,\n  // checkboxes and files.\n  if (isset($element['#process']) && !$element['#processed']) {\n    foreach ($element['#process'] as $process) {\n      $element = $process($element, $form_state, $form_state['complete form']);\n    }\n    $element['#processed'] = TRUE;\n  }\n\n  // We start off assuming all form elements are in the correct order.\n  $element['#sorted'] = TRUE;\n\n  // Recurse through all child elements.\n  $count = 0;\n  foreach (element_children($element) as $key) {\n    // Prior to checking properties of child elements, their default properties\n    // need to be loaded.\n    if (isset($element[$key]['#type']) && empty($element[$key]['#defaults_loaded']) && ($info = element_info($element[$key]['#type']))) {\n      $element[$key] += $info;\n      $element[$key]['#defaults_loaded'] = TRUE;\n    }\n\n    // Don't squash an existing tree value.\n    if (!isset($element[$key]['#tree'])) {\n      $element[$key]['#tree'] = $element['#tree'];\n    }\n\n    // Deny access to child elements if parent is denied.\n    if (isset($element['#access']) && !$element['#access']) {\n      $element[$key]['#access'] = FALSE;\n    }\n\n    // Make child elements inherit their parent's #disabled and #allow_focus\n    // values unless they specify their own.\n    foreach (array('#disabled', '#allow_focus') as $property) {\n      if (isset($element[$property]) && !isset($element[$key][$property])) {\n        $element[$key][$property] = $element[$property];\n      }\n    }\n\n    // Don't squash existing parents value.\n    if (!isset($element[$key]['#parents'])) {\n      // Check to see if a tree of child elements is present. If so,\n      // continue down the tree if required.\n      $element[$key]['#parents'] = $element[$key]['#tree'] && $element['#tree'] ? array_merge($element['#parents'], array($key)) : array($key);\n    }\n    // Ensure #array_parents follows the actual form structure.\n    $array_parents = isset($element['#array_parents']) ? $element['#array_parents'] : array();\n    $array_parents[] = $key;\n    $element[$key]['#array_parents'] = $array_parents;\n\n    // Assign a decimal placeholder weight to preserve original array order.\n    if (!isset($element[$key]['#weight'])) {\n      $element[$key]['#weight'] = $count/1000;\n    }\n    else {\n      // If one of the child elements has a weight then we will need to sort\n      // later.\n      unset($element['#sorted']);\n    }\n    $element[$key] = form_builder($form_id, $element[$key], $form_state);\n    $count++;\n  }\n\n  // The #after_build flag allows any piece of a form to be altered\n  // after normal input parsing has been completed.\n  if (isset($element['#after_build']) && !isset($element['#after_build_done'])) {\n    foreach ($element['#after_build'] as $function) {\n      $element = $function($element, $form_state);\n    }\n    $element['#after_build_done'] = TRUE;\n  }\n\n  // If there is a file element, we need to flip a flag so later the\n  // form encoding can be set.\n  if (isset($element['#type']) && $element['#type'] == 'file') {\n    $form_state['has_file_element'] = TRUE;\n  }\n\n  // Final tasks for the form element after form_builder() has run for all other\n  // elements.\n  if (isset($element['#type']) && $element['#type'] == 'form') {\n    // If there is a file element, we set the form encoding.\n    if (isset($form_state['has_file_element'])) {\n      $element['#attributes']['enctype'] = 'multipart/form-data';\n    }\n\n    // If a form contains a single textfield, and the ENTER key is pressed\n    // within it, Internet Explorer submits the form with no POST data\n    // identifying any submit button. Other browsers submit POST data as though\n    // the user clicked the first button. Therefore, to be as consistent as we\n    // can be across browsers, if no 'triggering_element' has been identified\n    // yet, default it to the first button.\n    if (!$form_state['programmed'] && !isset($form_state['triggering_element']) && !empty($form_state['buttons'])) {\n      $form_state['triggering_element'] = $form_state['buttons'][0];\n    }\n\n    // If the triggering element specifies \"button-level\" validation and submit\n    // handlers to run instead of the default form-level ones, then add those to\n    // the form state.\n    foreach (array('validate', 'submit') as $type) {\n      if (isset($form_state['triggering_element']['#' . $type])) {\n        $form_state[$type . '_handlers'] = $form_state['triggering_element']['#' . $type];\n      }\n    }\n\n    // If the triggering element executes submit handlers, then set the form\n    // state key that's needed for those handlers to run.\n    if (!empty($form_state['triggering_element']['#executes_submit_callback'])) {\n      $form_state['submitted'] = TRUE;\n    }\n\n    // Special processing if the triggering element is a button.\n    if (isset($form_state['triggering_element']['#button_type'])) {\n      // Because there are several ways in which the triggering element could\n      // have been determined (including from input variables set by JavaScript\n      // or fallback behavior implemented for IE), and because buttons often\n      // have their #name property not derived from their #parents property, we\n      // can't assume that input processing that's happened up until here has\n      // resulted in $form_state['values'][BUTTON_NAME] being set. But it's\n      // common for forms to have several buttons named 'op' and switch on\n      // $form_state['values']['op'] during submit handler execution.\n      $form_state['values'][$form_state['triggering_element']['#name']] = $form_state['triggering_element']['#value'];\n\n      // @todo Legacy support. Remove in Drupal 8.\n      $form_state['clicked_button'] = $form_state['triggering_element'];\n    }\n\n    // Update the copy of the complete form for usage in validation handlers.\n    $form_state['complete form'] = $element;\n  }\n  return $element;\n}\n\n/**\n * Populate the #value and #name properties of input elements so they\n * can be processed and rendered.\n */\nfunction _form_builder_handle_input_element($form_id, &$element, &$form_state) {\n  if (!isset($element['#name'])) {\n    $name = array_shift($element['#parents']);\n    $element['#name'] = $name;\n    if ($element['#type'] == 'file') {\n      // To make it easier to handle $_FILES in file.inc, we place all\n      // file fields in the 'files' array. Also, we do not support\n      // nested file names.\n      $element['#name'] = 'files[' . $element['#name'] . ']';\n    }\n    elseif (count($element['#parents'])) {\n      $element['#name'] .= '[' . implode('][', $element['#parents']) . ']';\n    }\n    array_unshift($element['#parents'], $name);\n  }\n\n  // Setting #disabled to TRUE results in user input being ignored, regardless\n  // of how the element is themed or whether JavaScript is used to change the\n  // control's attributes. However, it's good UI to let the user know that input\n  // is not wanted for the control. HTML supports two attributes for this:\n  // http://www.w3.org/TR/html401/interact/forms.html#h-17.12. If a form wants\n  // to start a control off with one of these attributes for UI purposes only,\n  // but still allow input to be processed if it's sumitted, it can set the\n  // desired attribute in #attributes directly rather than using #disabled.\n  // However, developers should think carefully about the accessibility\n  // implications of doing so: if the form expects input to be enterable under\n  // some condition triggered by JavaScript, how would someone who has\n  // JavaScript disabled trigger that condition? Instead, developers should\n  // consider whether a multi-step form would be more appropriate (#disabled can\n  // be changed from step to step). If one still decides to use JavaScript to\n  // affect when a control is enabled, then it is best for accessibility for the\n  // control to be enabled in the HTML, and disabled by JavaScript on document\n  // ready.\n  if (!empty($element['#disabled'])) {\n    if (!empty($element['#allow_focus'])) {\n      $element['#attributes']['readonly'] = 'readonly';\n    }\n    else {\n      $element['#attributes']['disabled'] = 'disabled';\n    }\n  }\n\n  // With JavaScript or other easy hacking, input can be submitted even for\n  // elements with #access=FALSE or #disabled=TRUE. For security, these must\n  // not be processed. Forms that set #disabled=TRUE on an element do not\n  // expect input for the element, and even forms submitted with\n  // drupal_form_submit() must not be able to get around this. Forms that set\n  // #access=FALSE on an element usually allow access for some users, so forms\n  // submitted with drupal_form_submit() may bypass access restriction and be\n  // treated as high-privelege users instead.\n  $process_input = empty($element['#disabled']) && ($form_state['programmed'] || ($form_state['process_input'] && (!isset($element['#access']) || $element['#access'])));\n\n  // Set the element's #value property.\n  if (!isset($element['#value']) && !array_key_exists('#value', $element)) {\n    $value_callback = !empty($element['#value_callback']) ? $element['#value_callback'] : 'form_type_' . $element['#type'] . '_value';\n    if ($process_input) {\n      // Get the input for the current element. NULL values in the input need to\n      // be explicitly distinguished from missing input. (see below)\n      $input_exists = NULL;\n      $input = drupal_array_get_nested_value($form_state['input'], $element['#parents'], $input_exists);\n      // For browser-submitted forms, the submitted values do not contain values\n      // for certain elements (empty multiple select, unchecked checkbox).\n      // During initial form processing, we add explicit NULL values for such\n      // elements in $form_state['input']. When rebuilding the form, we can\n      // distinguish elements having NULL input from elements that were not part\n      // of the initially submitted form and can therefore use default values\n      // for the latter, if required. Programmatically submitted forms can\n      // submit explicit NULL values when calling drupal_form_submit(), so we do\n      // not modify $form_state['input'] for them.\n      if (!$input_exists && !$form_state['rebuild'] && !$form_state['programmed']) {\n        // Add the necessary parent keys to $form_state['input'] and sets the\n        // element's input value to NULL.\n        drupal_array_set_nested_value($form_state['input'], $element['#parents'], NULL);\n        $input_exists = TRUE;\n      }\n      // If we have input for the current element, assign it to the #value\n      // property, optionally filtered through $value_callback.\n      if ($input_exists) {\n        if (function_exists($value_callback)) {\n          $element['#value'] = $value_callback($element, $input, $form_state);\n        }\n        if (!isset($element['#value']) && isset($input)) {\n          $element['#value'] = $input;\n        }\n      }\n      // Mark all posted values for validation.\n      if (isset($element['#value']) || (!empty($element['#required']))) {\n        $element['#needs_validation'] = TRUE;\n      }\n    }\n    // Load defaults.\n    if (!isset($element['#value'])) {\n      // Call #type_value without a second argument to request default_value handling.\n      if (function_exists($value_callback)) {\n        $element['#value'] = $value_callback($element, FALSE, $form_state);\n      }\n      // Final catch. If we haven't set a value yet, use the explicit default value.\n      // Avoid image buttons (which come with garbage value), so we only get value\n      // for the button actually clicked.\n      if (!isset($element['#value']) && empty($element['#has_garbage_value'])) {\n        $element['#value'] = isset($element['#default_value']) ? $element['#default_value'] : '';\n      }\n    }\n  }\n\n  // Determine which element (if any) triggered the submission of the form and\n  // keep track of all the clickable buttons in the form for\n  // form_state_values_clean(). Enforce the same input processing restrictions\n  // as above.\n  if ($process_input) {\n    // Detect if the element triggered the submission via AJAX.\n    if (_form_element_triggered_scripted_submission($element, $form_state)) {\n      $form_state['triggering_element'] = $element;\n    }\n\n    // If the form was submitted by the browser rather than via AJAX, then it\n    // can only have been triggered by a button, and we need to determine which\n    // button within the constraints of how browsers provide this information.\n    if (isset($element['#button_type'])) {\n      // All buttons in the form need to be tracked for\n      // form_state_values_clean() and for the form_builder() code that handles\n      // a form submission containing no button information in $_POST.\n      $form_state['buttons'][] = $element;\n      if (_form_button_was_clicked($element, $form_state)) {\n        $form_state['triggering_element'] = $element;\n      }\n    }\n  }\n\n  // Set the element's value in $form_state['values'], but only, if its key\n  // does not exist yet (a #value_callback may have already populated it).\n  if (!drupal_array_nested_key_exists($form_state['values'], $element['#parents'])) {\n    form_set_value($element, $element['#value'], $form_state);\n  }\n}\n\n/**\n * Helper function to handle the convoluted logic of button click detection.\n *\n * This detects button or non-button controls that trigger a form submission via\n * AJAX or some other scriptable environment. These environments can set the\n * special input key '_triggering_element_name' to identify the triggering\n * element. If the name alone doesn't identify the element uniquely, the input\n * key '_triggering_element_value' may also be set to require a match on element\n * value. An example where this is needed is if there are several buttons all\n * named 'op', and only differing in their value.\n */\nfunction _form_element_triggered_scripted_submission($element, &$form_state) {\n  if (!empty($form_state['input']['_triggering_element_name']) && $element['#name'] == $form_state['input']['_triggering_element_name']) {\n    if (empty($form_state['input']['_triggering_element_value']) || $form_state['input']['_triggering_element_value'] == $element['#value']) {\n      return TRUE;\n    }\n  }\n  return FALSE;\n}\n\n/**\n * Helper function to handle the convoluted logic of button click detection.\n *\n * This detects button controls that trigger a form submission by being clicked\n * and having the click processed by the browser rather than being captured by\n * JavaScript. Essentially, it detects if the button's name and value are part\n * of the POST data, but with extra code to deal with the convoluted way in\n * which browsers submit data for image button clicks.\n *\n * This does not detect button clicks processed by AJAX (that is done in\n * _form_element_triggered_scripted_submission()) and it does not detect form\n * submissions from Internet Explorer in response to an ENTER key pressed in a\n * textfield (form_builder() has extra code for that).\n *\n * Because this function contains only part of the logic needed to determine\n * $form_state['triggering_element'], it should not be called from anywhere\n * other than within the Form API. Form validation and submit handlers needing\n * to know which button was clicked should get that information from\n * $form_state['triggering_element'].\n */\nfunction _form_button_was_clicked($element, &$form_state) {\n  // First detect normal 'vanilla' button clicks. Traditionally, all\n  // standard buttons on a form share the same name (usually 'op'),\n  // and the specific return value is used to determine which was\n  // clicked. This ONLY works as long as $form['#name'] puts the\n  // value at the top level of the tree of $_POST data.\n  if (isset($form_state['input'][$element['#name']]) && $form_state['input'][$element['#name']] == $element['#value']) {\n    return TRUE;\n  }\n  // When image buttons are clicked, browsers do NOT pass the form element\n  // value in $_POST. Instead they pass an integer representing the\n  // coordinates of the click on the button image. This means that image\n  // buttons MUST have unique $form['#name'] values, but the details of\n  // their $_POST data should be ignored.\n  elseif (!empty($element['#has_garbage_value']) && isset($element['#value']) && $element['#value'] !== '') {\n    return TRUE;\n  }\n  return FALSE;\n}\n\n/**\n * Removes internal Form API elements and buttons from submitted form values.\n *\n * This function can be used when a module wants to store all submitted form\n * values, for example, by serializing them into a single database column. In\n * such cases, all internal Form API values and all form button elements should\n * not be contained, and this function allows to remove them before the module\n * proceeds to storage. Next to button elements, the following internal values\n * are removed:\n * - form_id\n * - form_token\n * - form_build_id\n * - op\n *\n * @param &$form_state\n *   A keyed array containing the current state of the form, including\n *   submitted form values; altered by reference.\n */\nfunction form_state_values_clean(&$form_state) {\n  // Remove internal Form API values.\n  unset($form_state['values']['form_id'], $form_state['values']['form_token'], $form_state['values']['form_build_id'], $form_state['values']['op']);\n\n  // Remove button values.\n  // form_builder() collects all button elements in a form. We remove the button\n  // value separately for each button element.\n  foreach ($form_state['buttons'] as $button) {\n    // Remove this button's value from the submitted form values by finding\n    // the value corresponding to this button.\n    // We iterate over the #parents of this button and move a reference to\n    // each parent in $form_state['values']. For example, if #parents is:\n    //   array('foo', 'bar', 'baz')\n    // then the corresponding $form_state['values'] part will look like this:\n    // array(\n    //   'foo' => array(\n    //     'bar' => array(\n    //       'baz' => 'button_value',\n    //     ),\n    //   ),\n    // )\n    // We start by (re)moving 'baz' to $last_parent, so we are able unset it\n    // at the end of the iteration. Initially, $values will contain a\n    // reference to $form_state['values'], but in the iteration we move the\n    // reference to $form_state['values']['foo'], and finally to\n    // $form_state['values']['foo']['bar'], which is the level where we can\n    // unset 'baz' (that is stored in $last_parent).\n    $parents = $button['#parents'];\n    $values = &$form_state['values'];\n    $last_parent = array_pop($parents);\n    foreach ($parents as $parent) {\n      $values = &$values[$parent];\n    }\n    unset($values[$last_parent]);\n  }\n}\n\n/**\n * Helper function to determine the value for an image button form element.\n *\n * @param $form\n *   The form element whose value is being populated.\n * @param $input\n *   The incoming input to populate the form element. If this is FALSE,\n *   the element's default value should be returned.\n * @param $form_state\n *   A keyed array containing the current state of the form.\n * @return\n *   The data that will appear in the $form_state['values'] collection\n *   for this element. Return nothing to use the default.\n */\nfunction form_type_image_button_value($form, $input, $form_state) {\n  if ($input !== FALSE) {\n    if (!empty($input)) {\n      // If we're dealing with Mozilla or Opera, we're lucky. It will\n      // return a proper value, and we can get on with things.\n      return $form['#return_value'];\n    }\n    else {\n      // Unfortunately, in IE we never get back a proper value for THIS\n      // form element. Instead, we get back two split values: one for the\n      // X and one for the Y coordinates on which the user clicked the\n      // button. We'll find this element in the #post data, and search\n      // in the same spot for its name, with '_x'.\n      $input = $form_state['input'];\n      foreach (explode('[', $form['#name']) as $element_name) {\n        // chop off the ] that may exist.\n        if (substr($element_name, -1) == ']') {\n          $element_name = substr($element_name, 0, -1);\n        }\n\n        if (!isset($input[$element_name])) {\n          if (isset($input[$element_name . '_x'])) {\n            return $form['#return_value'];\n          }\n          return NULL;\n        }\n        $input = $input[$element_name];\n      }\n      return $form['#return_value'];\n    }\n  }\n}\n\n/**\n * Helper function to determine the value for a checkbox form element.\n *\n * @param $form\n *   The form element whose value is being populated.\n*  @param $input\n *   The incoming input to populate the form element. If this is FALSE,\n *   the element's default value should be returned.\n * @return\n *   The data that will appear in the $element_state['values'] collection\n *   for this element. Return nothing to use the default.\n */\nfunction form_type_checkbox_value($element, $input = FALSE) {\n  if ($input !== FALSE) {\n    // Successful (checked) checkboxes are present with a value (possibly '0').\n    // http://www.w3.org/TR/html401/interact/forms.html#successful-controls\n    // For an unchecked checkbox, we return integer 0, so we can explicitly\n    // test for a value different than string '0'.\n    return isset($input) ? $element['#return_value'] : 0;\n  }\n}\n\n/**\n * Helper function to determine the value for a checkboxes form element.\n *\n * @param $element\n *   The form element whose value is being populated.\n * @param $input\n *   The incoming input to populate the form element. If this is FALSE,\n *   the element's default value should be returned.\n * @return\n *   The data that will appear in the $element_state['values'] collection\n *   for this element. Return nothing to use the default.\n */\nfunction form_type_checkboxes_value($element, $input = FALSE) {\n  if ($input === FALSE) {\n    $value = array();\n    $element += array('#default_value' => array());\n    foreach ($element['#default_value'] as $key) {\n      $value[$key] = $key;\n    }\n    return $value;\n  }\n  elseif (is_array($input)) {\n    // Programmatic form submissions use NULL to indicate that a checkbox\n    // should be unchecked; see drupal_form_submit(). We therefore remove all\n    // NULL elements from the array before constructing the return value, to\n    // simulate the behavior of web browsers (which do not send unchecked\n    // checkboxes to the server at all). This will not affect non-programmatic\n    // form submissions, since a checkbox can never legitimately be NULL.\n    foreach ($input as $key => $value) {\n      if (!isset($value)) {\n        unset($input[$key]);\n      }\n    }\n    return drupal_map_assoc($input);\n  }\n  else {\n    return array();\n  }\n}\n\n/**\n * Helper function to determine the value for a password_confirm form\n * element.\n *\n * @param $element\n *   The form element whose value is being populated.\n * @param $input\n *   The incoming input to populate the form element. If this is FALSE,\n *   the element's default value should be returned.\n * @return\n *   The data that will appear in the $element_state['values'] collection\n *   for this element. Return nothing to use the default.\n */\nfunction form_type_password_confirm_value($element, $input = FALSE) {\n  if ($input === FALSE) {\n    $element += array('#default_value' => array());\n    return $element['#default_value'] + array('pass1' => '', 'pass2' => '');\n  }\n}\n\n/**\n * Helper function to determine the value for a select form element.\n *\n * @param $element\n *   The form element whose value is being populated.\n * @param $input\n *   The incoming input to populate the form element. If this is FALSE,\n *   the element's default value should be returned.\n * @return\n *   The data that will appear in the $element_state['values'] collection\n *   for this element. Return nothing to use the default.\n */\nfunction form_type_select_value($element, $input = FALSE) {\n  if ($input !== FALSE) {\n    if (isset($element['#multiple']) && $element['#multiple']) {\n      // If an enabled multi-select submits NULL, it means all items are\n      // unselected. A disabled multi-select always submits NULL, and the\n      // default value should be used.\n      if (empty($element['#disabled'])) {\n        return (is_array($input)) ? drupal_map_assoc($input) : array();\n      }\n      else {\n        return (isset($element['#default_value']) && is_array($element['#default_value'])) ? $element['#default_value'] : array();\n      }\n    }\n    // Non-multiple select elements may have an empty option preprended to them\n    // (see form_process_select()). When this occurs, usually #empty_value is\n    // an empty string, but some forms set #empty_value to integer 0 or some\n    // other non-string constant. PHP receives all submitted form input as\n    // strings, but if the empty option is selected, set the value to match the\n    // empty value exactly.\n    elseif (isset($element['#empty_value']) && $input === (string) $element['#empty_value']) {\n      return $element['#empty_value'];\n    }\n    else {\n      return $input;\n    }\n  }\n}\n\n/**\n * Helper function to determine the value for a textfield form element.\n *\n * @param $element\n *   The form element whose value is being populated.\n * @param $input\n *   The incoming input to populate the form element. If this is FALSE,\n *   the element's default value should be returned.\n * @return\n *   The data that will appear in the $element_state['values'] collection\n *   for this element. Return nothing to use the default.\n */\nfunction form_type_textfield_value($element, $input = FALSE) {\n  if ($input !== FALSE && $input !== NULL) {\n    // Equate $input to the form value to ensure it's marked for\n    // validation.\n    return str_replace(array(\"\\r\", \"\\n\"), '', $input);\n  }\n}\n\n/**\n * Helper function to determine the value for form's token value.\n *\n * @param $element\n *   The form element whose value is being populated.\n * @param $input\n *   The incoming input to populate the form element. If this is FALSE,\n *   the element's default value should be returned.\n * @return\n *   The data that will appear in the $element_state['values'] collection\n *   for this element. Return nothing to use the default.\n */\nfunction form_type_token_value($element, $input = FALSE) {\n  if ($input !== FALSE) {\n    return (string) $input;\n  }\n}\n\n/**\n * Change submitted form values during form validation.\n *\n * Use this function to change the submitted value of a form element in a form\n * validation function, so that the changed value persists in $form_state\n * through to the submission handlers.\n *\n * Note that form validation functions are specified in the '#validate'\n * component of the form array (the value of $form['#validate'] is an array of\n * validation function names). If the form does not originate in your module,\n * you can implement hook_form_FORM_ID_alter() to add a validation function\n * to $form['#validate'].\n *\n * @param $element\n *   The form element that should have its value updated; in most cases you can\n *   just pass in the element from the $form array, although the only component\n *   that is actually used is '#parents'. If constructing yourself, set\n *   $element['#parents'] to be an array giving the path through the form\n *   array's keys to the element whose value you want to update. For instance,\n *   if you want to update the value of $form['elem1']['elem2'], which should be\n *   stored in $form_state['values']['elem1']['elem2'], you would set\n *   $element['#parents'] = array('elem1','elem2').\n * @param $value\n *   The new value for the form element.\n * @param $form_state\n *   Form state array where the value change should be recorded.\n */\nfunction form_set_value($element, $value, &$form_state) {\n  drupal_array_set_nested_value($form_state['values'], $element['#parents'], $value);\n}\n\n/**\n * Allows PHP array processing of multiple select options with the same value.\n *\n * Used for form select elements which need to validate HTML option groups\n * and multiple options which may return the same value. Associative PHP arrays\n * cannot handle these structures, since they share a common key.\n *\n * @param $array\n *   The form options array to process.\n *\n * @return\n *   An array with all hierarchical elements flattened to a single array.\n */\nfunction form_options_flatten($array) {\n  // Always reset static var when first entering the recursion.\n  drupal_static_reset('_form_options_flatten');\n  return _form_options_flatten($array);\n}\n\n/**\n * Helper function for form_options_flatten().\n *\n * Iterates over arrays which may share common values and produces a flat\n * array that has removed duplicate keys. Also handles cases where objects\n * are passed as array values.\n */\nfunction _form_options_flatten($array) {\n  $return = &drupal_static(__FUNCTION__);\n\n  foreach ($array as $key => $value) {\n    if (is_object($value)) {\n      _form_options_flatten($value->option);\n    }\n    elseif (is_array($value)) {\n      _form_options_flatten($value);\n    }\n    else {\n      $return[$key] = 1;\n    }\n  }\n\n  return $return;\n}\n\n/**\n * Processes a select list form element.\n *\n * This process callback is mandatory for select fields, since all user agents\n * automatically preselect the first available option of single (non-multiple)\n * select lists.\n *\n * @param $element\n *   The form element to process. Properties used:\n *   - #multiple: (optional) Indicates whether one or more options can be\n *     selected. Defaults to FALSE.\n *   - #default_value: Must be NULL or not set in case there is no value for the\n *     element yet, in which case a first default option is inserted by default.\n *     Whether this first option is a valid option depends on whether the field\n *     is #required or not.\n *   - #required: (optional) Whether the user needs to select an option (TRUE)\n *     or not (FALSE). Defaults to FALSE.\n *   - #empty_option: (optional) The label to show for the first default option.\n *     By default, the label is automatically set to \"- Please select -\" for a\n *     required field and \"- None -\" for an optional field.\n *   - #empty_value: (optional) The value for the first default option, which is\n *     used to determine whether the user submitted a value or not.\n *     - If #required is TRUE, this defaults to '' (an empty string).\n *     - If #required is not TRUE and this value isn't set, then no extra option\n *       is added to the select control, leaving the control in a slightly\n *       illogical state, because there's no way for the user to select nothing,\n *       since all user agents automatically preselect the first available\n *       option. But people are used to this being the behavior of select\n *       controls.\n *       @todo Address the above issue in Drupal 8.\n *     - If #required is not TRUE and this value is set (most commonly to an\n *       empty string), then an extra option (see #empty_option above)\n *       representing a \"non-selection\" is added with this as its value.\n *\n * @see _form_validate()\n */\nfunction form_process_select($element) {\n  // #multiple select fields need a special #name.\n  if ($element['#multiple']) {\n    $element['#attributes']['multiple'] = 'multiple';\n    $element['#attributes']['name'] = $element['#name'] . '[]';\n  }\n  // A non-#multiple select needs special handling to prevent user agents from\n  // preselecting the first option without intention. #multiple select lists do\n  // not get an empty option, as it would not make sense, user interface-wise.\n  else {\n    $required = $element['#required'];\n    // If the element is required and there is no #default_value, then add an\n    // empty option that will fail validation, so that the user is required to\n    // make a choice. Also, if there's a value for #empty_value or\n    // #empty_option, then add an option that represents emptiness.\n    if (($required && !isset($element['#default_value'])) || isset($element['#empty_value']) || isset($element['#empty_option'])) {\n      $element += array(\n        '#empty_value' => '',\n        '#empty_option' => $required ? t('- Select - ') : t('- None -'),\n      );\n      // The empty option is prepended to #options and purposively not merged\n      // to prevent another option in #options mistakenly using the same value\n      // as #empty_value.\n      $empty_option = array($element['#empty_value'] => $element['#empty_option']);\n      $element['#options'] = $empty_option + $element['#options'];\n    }\n  }\n  return $element;\n}\n\n/**\n * Returns HTML for a select form element.\n *\n * It is possible to group options together; to do this, change the format of\n * $options to an associative array in which the keys are group labels, and the\n * values are associative arrays in the normal $options format.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #title, #value, #options, #description, #extra,\n *     #multiple, #required, #name, #attributes, #size.\n *\n * @ingroup themeable\n */\nfunction theme_select($variables) {\n  $element = $variables['element'];\n  element_set_attributes($element, array('id', 'name', 'size'));\n  _form_set_class($element, array('form-select'));\n\n  return '<select' . drupal_attributes($element['#attributes']) . '>' . form_select_options($element) . '</select>';\n}\n\n/**\n * Converts a select form element's options array into an HTML.\n *\n * @param $element\n *   An associative array containing the properties of the element.\n * @param $choices\n *   Mixed: Either an associative array of items to list as choices, or an\n *   object with an 'option' member that is an associative array. This\n *   parameter is only used internally and should not be passed.\n * @return\n *   An HTML string of options for the select form element.\n */\nfunction form_select_options($element, $choices = NULL) {\n  if (!isset($choices)) {\n    $choices = $element['#options'];\n  }\n  // array_key_exists() accommodates the rare event where $element['#value'] is NULL.\n  // isset() fails in this situation.\n  $value_valid = isset($element['#value']) || array_key_exists('#value', $element);\n  $value_is_array = $value_valid && is_array($element['#value']);\n  $options = '';\n  foreach ($choices as $key => $choice) {\n    if (is_array($choice)) {\n      $options .= '<optgroup label=\"' . $key . '\">';\n      $options .= form_select_options($element, $choice);\n      $options .= '</optgroup>';\n    }\n    elseif (is_object($choice)) {\n      $options .= form_select_options($element, $choice->option);\n    }\n    else {\n      $key = (string) $key;\n      if ($value_valid && (!$value_is_array && (string) $element['#value'] === $key || ($value_is_array && in_array($key, $element['#value'])))) {\n        $selected = ' selected=\"selected\"';\n      }\n      else {\n        $selected = '';\n      }\n      $options .= '<option value=\"' . check_plain($key) . '\"' . $selected . '>' . check_plain($choice) . '</option>';\n    }\n  }\n  return $options;\n}\n\n/**\n * Traverses a select element's #option array looking for any values\n * that hold the given key. Returns an array of indexes that match.\n *\n * This function is useful if you need to modify the options that are\n * already in a form element; for example, to remove choices which are\n * not valid because of additional filters imposed by another module.\n * One example might be altering the choices in a taxonomy selector.\n * To correctly handle the case of a multiple hierarchy taxonomy,\n * #options arrays can now hold an array of objects, instead of a\n * direct mapping of keys to labels, so that multiple choices in the\n * selector can have the same key (and label). This makes it difficult\n * to manipulate directly, which is why this helper function exists.\n *\n * This function does not support optgroups (when the elements of the\n * #options array are themselves arrays), and will return FALSE if\n * arrays are found. The caller must either flatten/restore or\n * manually do their manipulations in this case, since returning the\n * index is not sufficient, and supporting this would make the\n * \"helper\" too complicated and cumbersome to be of any help.\n *\n * As usual with functions that can return array() or FALSE, do not\n * forget to use === and !== if needed.\n *\n * @param $element\n *   The select element to search.\n * @param $key\n *   The key to look for.\n * @return\n *   An array of indexes that match the given $key. Array will be\n *   empty if no elements were found. FALSE if optgroups were found.\n */\nfunction form_get_options($element, $key) {\n  $keys = array();\n  foreach ($element['#options'] as $index => $choice) {\n    if (is_array($choice)) {\n      return FALSE;\n    }\n    elseif (is_object($choice)) {\n      if (isset($choice->option[$key])) {\n        $keys[] = $index;\n      }\n    }\n    elseif ($index == $key) {\n      $keys[] = $index;\n    }\n  }\n  return $keys;\n}\n\n/**\n * Returns HTML for a fieldset form element and its children.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #attributes, #children, #collapsed, #collapsible,\n *     #description, #id, #title, #value.\n *\n * @ingroup themeable\n */\nfunction theme_fieldset($variables) {\n  $element = $variables['element'];\n  element_set_attributes($element, array('id'));\n  _form_set_class($element, array('form-wrapper'));\n\n  $output = '<fieldset' . drupal_attributes($element['#attributes']) . '>';\n  if (!empty($element['#title'])) {\n    // Always wrap fieldset legends in a SPAN for CSS positioning.\n    $output .= '<legend><span class=\"fieldset-legend\">' . $element['#title'] . '</span></legend>';\n  }\n  $output .= '<div class=\"fieldset-wrapper\">';\n  if (!empty($element['#description'])) {\n    $output .= '<div class=\"fieldset-description\">' . $element['#description'] . '</div>';\n  }\n  $output .= $element['#children'];\n  if (isset($element['#value'])) {\n    $output .= $element['#value'];\n  }\n  $output .= '</div>';\n  $output .= \"</fieldset>\\n\";\n  return $output;\n}\n\n/**\n * Returns HTML for a radio button form element.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #required, #return_value, #value, #attributes, #title,\n *     #description\n *\n * @ingroup themeable\n */\nfunction theme_radio($variables) {\n  $element = $variables['element'];\n  $element['#attributes']['type'] = 'radio';\n  element_set_attributes($element, array('id', 'name', '#return_value' => 'value'));\n\n  if (isset($element['#return_value']) && check_plain($element['#value']) == $element['#return_value']) {\n    $element['#attributes']['checked'] = 'checked';\n  }\n  _form_set_class($element, array('form-radio'));\n\n  return '<input' . drupal_attributes($element['#attributes']) . ' />';\n}\n\n/**\n * Returns HTML for a set of radio button form elements.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #title, #value, #options, #description, #required,\n *     #attributes, #children.\n *\n * @ingroup themeable\n */\nfunction theme_radios($variables) {\n  $element = $variables['element'];\n  $attributes = array();\n  if (isset($element['#id'])) {\n    $attributes['id'] = $element['#id'];\n  }\n  $attributes['class'] = 'form-radios';\n  if (!empty($element['#attributes']['class'])) {\n    $attributes['class'] .= ' ' . implode(' ', $element['#attributes']['class']);\n  }\n  return '<div' . drupal_attributes($attributes) . '>' . (!empty($element['#children']) ? $element['#children'] : '') . '</div>';\n}\n\n/**\n * Expand a password_confirm field into two text boxes.\n */\nfunction form_process_password_confirm($element) {\n  $element['pass1'] =  array(\n    '#type' => 'password',\n    '#title' => t('Password'),\n    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass1'],\n    '#required' => $element['#required'],\n    '#attributes' => array('class' => array('password-field')),\n  );\n  $element['pass2'] =  array(\n    '#type' => 'password',\n    '#title' => t('Confirm password'),\n    '#value' => empty($element['#value']) ? NULL : $element['#value']['pass2'],\n    '#required' => $element['#required'],\n    '#attributes' => array('class' => array('password-confirm')),\n  );\n  $element['#element_validate'] = array('password_confirm_validate');\n  $element['#tree'] = TRUE;\n\n  if (isset($element['#size'])) {\n    $element['pass1']['#size'] = $element['pass2']['#size'] = $element['#size'];\n  }\n\n  return $element;\n}\n\n/**\n * Validate password_confirm element.\n */\nfunction password_confirm_validate($element, &$element_state) {\n  $pass1 = trim($element['pass1']['#value']);\n  $pass2 = trim($element['pass2']['#value']);\n  if (!empty($pass1) || !empty($pass2)) {\n    if (strcmp($pass1, $pass2)) {\n      form_error($element, t('The specified passwords do not match.'));\n    }\n  }\n  elseif ($element['#required'] && !empty($element_state['input'])) {\n    form_error($element, t('Password field is required.'));\n  }\n\n  // Password field must be converted from a two-element array into a single\n  // string regardless of validation results.\n  form_set_value($element['pass1'], NULL, $element_state);\n  form_set_value($element['pass2'], NULL, $element_state);\n  form_set_value($element, $pass1, $element_state);\n\n  return $element;\n\n}\n\n/**\n * Returns HTML for a date selection form element.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #title, #value, #options, #description, #required,\n *     #attributes.\n *\n * @ingroup themeable\n */\nfunction theme_date($variables) {\n  $element = $variables['element'];\n  return '<div class=\"container-inline\">' . drupal_render_children($element) . '</div>';\n}\n\n/**\n * Roll out a single date element.\n */\nfunction form_process_date($element) {\n  // Default to current date\n  if (empty($element['#value'])) {\n    $element['#value'] = array(\n      'day' => format_date(REQUEST_TIME, 'custom', 'j'),\n      'month' => format_date(REQUEST_TIME, 'custom', 'n'),\n      'year' => format_date(REQUEST_TIME, 'custom', 'Y'),\n    );\n  }\n\n  $element['#tree'] = TRUE;\n\n  // Determine the order of day, month, year in the site's chosen date format.\n  $format = variable_get('date_format_short', 'm/d/Y - H:i');\n  $sort = array();\n  $sort['day'] = max(strpos($format, 'd'), strpos($format, 'j'));\n  $sort['month'] = max(strpos($format, 'm'), strpos($format, 'M'));\n  $sort['year'] = strpos($format, 'Y');\n  asort($sort);\n  $order = array_keys($sort);\n\n  // Output multi-selector for date.\n  foreach ($order as $type) {\n    switch ($type) {\n      case 'day':\n        $options = drupal_map_assoc(range(1, 31));\n        break;\n\n      case 'month':\n        $options = drupal_map_assoc(range(1, 12), 'map_month');\n        break;\n\n      case 'year':\n        $options = drupal_map_assoc(range(1900, 2050));\n        break;\n    }\n\n    $element[$type] = array(\n      '#type' => 'select',\n      '#value' => $element['#value'][$type],\n      '#attributes' => $element['#attributes'],\n      '#options' => $options,\n    );\n  }\n\n  return $element;\n}\n\n/**\n * Validates the date type to stop dates like February 30, 2006.\n */\nfunction date_validate($form) {\n  if (!checkdate($form['#value']['month'], $form['#value']['day'], $form['#value']['year'])) {\n    form_error($form, t('The specified date is invalid.'));\n  }\n}\n\n/**\n * Helper function for usage with drupal_map_assoc to display month names.\n */\nfunction map_month($month) {\n  $months = &drupal_static(__FUNCTION__, array(\n    1 => 'Jan',\n    2 => 'Feb',\n    3 => 'Mar',\n    4 => 'Apr',\n    5 => 'May',\n    6 => 'Jun',\n    7 => 'Jul',\n    8 => 'Aug',\n    9 => 'Sep',\n    10 => 'Oct',\n    11 => 'Nov',\n    12 => 'Dec',\n  ));\n  return t($months[$month]);\n}\n\n/**\n * If no default value is set for weight select boxes, use 0.\n */\nfunction weight_value(&$form) {\n  if (isset($form['#default_value'])) {\n    $form['#value'] = $form['#default_value'];\n  }\n  else {\n    $form['#value'] = 0;\n  }\n}\n\n/**\n * Roll out a single radios element to a list of radios,\n * using the options array as index.\n */\nfunction form_process_radios($element) {\n  if (count($element['#options']) > 0) {\n    foreach ($element['#options'] as $key => $choice) {\n      if (!isset($element[$key])) {\n        // Generate the parents as the autogenerator does, so we will have a\n        // unique id for each radio button.\n        $parents_for_id = array_merge($element['#parents'], array($key));\n        $element[$key] = array(\n          '#type' => 'radio',\n          '#title' => $choice,\n          '#return_value' => check_plain($key),\n          '#default_value' => isset($element['#default_value']) ? $element['#default_value'] : NULL,\n          '#attributes' => $element['#attributes'],\n          '#parents' => $element['#parents'],\n          '#id' => drupal_html_id('edit-' . implode('-', $parents_for_id)),\n          '#ajax' => isset($element['#ajax']) ? $element['#ajax'] : NULL,\n        );\n      }\n    }\n  }\n  return $element;\n}\n\n/**\n * Returns HTML for a checkbox form element.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #title, #value, #return_value, #description, #required,\n *     #attributes.\n *\n * @ingroup themeable\n */\nfunction theme_checkbox($variables) {\n  $element = $variables['element'];\n  $t = get_t();\n  $element['#attributes']['type'] = 'checkbox';\n  element_set_attributes($element, array('id', 'name', '#return_value' => 'value'));\n\n  // Unchecked checkbox has #value of integer 0.\n  if (isset($element['#return_value']) && isset($element['#value']) && $element['#value'] !== 0 && $element['#value'] == $element['#return_value']) {\n    $element['#attributes']['checked'] = 'checked';\n  }\n  _form_set_class($element, array('form-checkbox'));\n\n  return '<input' . drupal_attributes($element['#attributes']) . ' />';\n}\n\n/**\n * Returns HTML for a set of checkbox form elements.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #children, #attributes.\n *\n * @ingroup themeable\n */\nfunction theme_checkboxes($variables) {\n  $element = $variables['element'];\n  $attributes = array();\n  if (isset($element['#id'])) {\n    $attributes['id'] = $element['#id'];\n  }\n  $attributes['class'][] = 'form-checkboxes';\n  if (!empty($element['#attributes']['class'])) {\n    $attributes['class'] = array_merge($attributes['class'], $element['#attributes']['class']);\n  }\n  return '<div' . drupal_attributes($attributes) . '>' . (!empty($element['#children']) ? $element['#children'] : '') . '</div>';\n}\n\n/**\n * Add form_element theming to an element if title or description is set.\n *\n * This is used as a pre render function for checkboxes and radios.\n */\nfunction form_pre_render_conditional_form_element($element) {\n  // Set the element's title attribute to show #title as a tooltip, if needed.\n  if (isset($element['#title']) && $element['#title_display'] == 'attribute') {\n    $element['#attributes']['title'] = $element['#title'];\n    if (!empty($element['#required'])) {\n      // Append an indication that this field is required.\n      $element['#attributes']['title'] .= ' (' . $t('Required') . ')';\n    }\n  }\n\n  if (isset($element['#title']) || isset($element['#description'])) {\n    $element['#theme_wrappers'][] = 'form_element';\n  }\n  return $element;\n}\n\nfunction form_process_checkboxes($element) {\n  $value = is_array($element['#value']) ? $element['#value'] : array();\n  $element['#tree'] = TRUE;\n  if (count($element['#options']) > 0) {\n    if (!isset($element['#default_value']) || $element['#default_value'] == 0) {\n      $element['#default_value'] = array();\n    }\n    foreach ($element['#options'] as $key => $choice) {\n      if (!isset($element[$key])) {\n        $element[$key] = array(\n          '#type' => 'checkbox',\n          '#processed' => TRUE,\n          '#title' => $choice,\n          '#return_value' => $key,\n          '#default_value' => isset($value[$key]) ? $key : NULL,\n          '#attributes' => $element['#attributes'],\n          '#ajax' => isset($element['#ajax']) ? $element['#ajax'] : NULL,\n        );\n      }\n    }\n  }\n  return $element;\n}\n\n/**\n * Processes a form actions container element.\n *\n * @param $element\n *   An associative array containing the properties and children of the\n *   form actions container.\n * @param $form_state\n *   The $form_state array for the form this element belongs to.\n *\n * @return\n *   The processed element.\n */\nfunction form_process_actions($element, &$form_state) {\n  $element['#attributes']['class'][] = 'form-actions';\n  return $element;\n}\n\n/**\n * Processes a container element.\n *\n * @param $element\n *   An associative array containing the properties and children of the\n *   container.\n * @param $form_state\n *   The $form_state array for the form this element belongs to.\n * @return\n *   The processed element.\n */\nfunction form_process_container($element, &$form_state) {\n  // Generate the ID of the element if it's not explicitly given.\n  if (!isset($element['#id'])) {\n    $element['#id'] = drupal_html_id(implode('-', $element['#parents']) . '-wrapper');\n  }\n  return $element;\n}\n\n/**\n * Returns HTML for a container for grouped form items.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #id, #attributes, #children.\n *\n * @ingroup themeable\n */\nfunction theme_container($variables) {\n  $element = $variables['element'];\n  if (!isset($element['#attributes']['id'])) {\n    $element['#attributes']['id'] = $element['#id'];\n  }\n  // Force the 'form-wrapper' class.\n  $element['#attributes']['class'][] = 'form-wrapper';\n  return '<div' . drupal_attributes($element['#attributes']) . '>' . $element['#children'] . '</div>';\n}\n\n/**\n * Returns HTML for a table with radio buttons or checkboxes.\n *\n * An example of per-row options:\n * @code\n * $options = array();\n * $options[0]['title'] = \"A red row\"\n * $options[0]['#attributes'] = array ('class' => array('red-row'));\n * $options[1]['title'] = \"A blue row\"\n * $options[1]['#attributes'] = array ('class' => array('blue-row'));\n *\n * $form['myselector'] = array (\n * '#type' => 'tableselect',\n * '#title' => 'My Selector'\n * '#options' => $options,\n * );\n * @endcode\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties and children of\n *     the tableselect element. Properties used: #header, #options, #empty,\n *     and #js_select. The #options property is an array of selection options;\n *     each array element of #options is an array of properties. These\n *     properties can include #attributes, which is added to the\n *     table row's HTML attributes; see theme_table().\n *\n * @ingroup themeable\n */\nfunction theme_tableselect($variables) {\n  $element = $variables['element'];\n  $rows = array();\n  $header = $element['#header'];\n  if (!empty($element['#options'])) {\n    // Generate a table row for each selectable item in #options.\n    foreach (element_children($element) as $key) {\n      $row = array();\n\n      $row['data'] = array();\n      if (isset($element['#options'][$key]['#attributes'])) {\n        $row += $element['#options'][$key]['#attributes'];\n      }\n      // Render the checkbox / radio element.\n      $row['data'][] = drupal_render($element[$key]);\n\n      // As theme_table only maps header and row columns by order, create the\n      // correct order by iterating over the header fields.\n      foreach ($element['#header'] as $fieldname => $title) {\n        $row['data'][] = $element['#options'][$key][$fieldname];\n      }\n      $rows[] = $row;\n    }\n    // Add an empty header or a \"Select all\" checkbox to provide room for the\n    // checkboxes/radios in the first table column.\n    if ($element['#js_select']) {\n      // Add a \"Select all\" checkbox.\n      drupal_add_js('misc/tableselect.js');\n      array_unshift($header, array('class' => array('select-all')));\n    }\n    else {\n      // Add an empty header when radio buttons are displayed or a \"Select all\"\n      // checkbox is not desired.\n      array_unshift($header, '');\n    }\n  }\n  return theme('table', array('header' => $header, 'rows' => $rows, 'empty' => $element['#empty'], 'attributes' => $element['#attributes']));\n}\n\n/**\n * Create the correct amount of checkbox or radio elements to populate the table.\n *\n * @param $element\n *   An associative array containing the properties and children of the\n *   tableselect element.\n * @return\n *   The processed element.\n */\nfunction form_process_tableselect($element) {\n\n  if ($element['#multiple']) {\n    $value = is_array($element['#value']) ? $element['#value'] : array();\n  }\n  else {\n    // Advanced selection behaviour make no sense for radios.\n    $element['#js_select'] = FALSE;\n  }\n\n  $element['#tree'] = TRUE;\n\n  if (count($element['#options']) > 0) {\n    if (!isset($element['#default_value']) || $element['#default_value'] === 0) {\n      $element['#default_value'] = array();\n    }\n\n    // Create a checkbox or radio for each item in #options in such a way that\n    // the value of the tableselect element behaves as if it had been of type\n    // checkboxes or radios.\n    foreach ($element['#options'] as $key => $choice) {\n      // Do not overwrite manually created children.\n      if (!isset($element[$key])) {\n        if ($element['#multiple']) {\n          $element[$key] = array(\n            '#type' => 'checkbox',\n            '#title' => '',\n            '#return_value' => $key,\n            '#default_value' => isset($value[$key]) ? $key : NULL,\n            '#attributes' => $element['#attributes'],\n          );\n        }\n        else {\n          // Generate the parents as the autogenerator does, so we will have a\n          // unique id for each radio button.\n          $parents_for_id = array_merge($element['#parents'], array($key));\n          $element[$key] = array(\n            '#type' => 'radio',\n            '#title' => '',\n            '#return_value' => $key,\n            '#default_value' => ($element['#default_value'] == $key) ? $key : NULL,\n            '#attributes' => $element['#attributes'],\n            '#parents' => $element['#parents'],\n            '#id' => drupal_html_id('edit-' . implode('-', $parents_for_id)),\n            '#ajax' => isset($element['#ajax']) ? $element['#ajax'] : NULL,\n          );\n        }\n        if (isset($element['#options'][$key]['#weight'])) {\n          $element[$key]['#weight'] = $element['#options'][$key]['#weight'];\n        }\n      }\n    }\n  }\n  else {\n    $element['#value'] = array();\n  }\n  return $element;\n}\n\n/**\n * Adds fieldsets to the specified group or adds group members to this\n * fieldset.\n *\n * @param &$element\n *   An associative array containing the properties and children of the\n *   fieldset. Note that $element must be taken by reference here, so processed\n *   child elements are taken over into $form_state.\n * @param $form_state\n *   The $form_state array for the form this fieldset belongs to.\n * @return\n *   The processed element.\n */\nfunction form_process_fieldset(&$element, &$form_state) {\n  $parents = implode('][', $element['#parents']);\n\n  // Each fieldset forms a new group. The #type 'vertical_tabs' basically only\n  // injects a new fieldset.\n  $form_state['groups'][$parents]['#group_exists'] = TRUE;\n  $element['#groups'] = &$form_state['groups'];\n\n  // Process vertical tabs group member fieldsets.\n  if (isset($element['#group'])) {\n    // Add this fieldset to the defined group (by reference).\n    $group = $element['#group'];\n    $form_state['groups'][$group][] = &$element;\n  }\n\n  // Contains form element summary functionalities.\n  $element['#attached']['js']['misc/form.js'] = array('group' => JS_LIBRARY, 'weight' => 1);\n\n  // The .form-wrapper class is required for #states to treat fieldsets like\n  // containers.\n  if (!isset($element['#attributes']['class'])) {\n    $element['#attributes']['class'] = array();\n  }\n\n  // Collapsible fieldsets\n  if (!empty($element['#collapsible'])) {\n    $element['#attached']['js'][] = 'misc/collapse.js';\n    $element['#attributes']['class'][] = 'collapsible';\n    if (!empty($element['#collapsed'])) {\n      $element['#attributes']['class'][] = 'collapsed';\n    }\n  }\n\n  return $element;\n}\n\n/**\n * Adds members of this group as actual elements for rendering.\n *\n * @param $element\n *   An associative array containing the properties and children of the\n *   fieldset.\n *\n * @return\n *   The modified element with all group members.\n */\nfunction form_pre_render_fieldset($element) {\n  // Fieldsets may be rendered outside of a Form API context.\n  if (!isset($element['#parents']) || !isset($element['#groups'])) {\n    return $element;\n  }\n  // Inject group member elements belonging to this group.\n  $parents = implode('][', $element['#parents']);\n  $children = element_children($element['#groups'][$parents]);\n  if (!empty($children)) {\n    foreach ($children as $key) {\n      // Break references and indicate that the element should be rendered as\n      // group member.\n      $child = (array) $element['#groups'][$parents][$key];\n      $child['#group_fieldset'] = TRUE;\n      // Inject the element as new child element.\n      $element[] = $child;\n\n      $sort = TRUE;\n    }\n    // Re-sort the element's children if we injected group member elements.\n    if (isset($sort)) {\n      $element['#sorted'] = FALSE;\n    }\n  }\n\n  if (isset($element['#group'])) {\n    $group = $element['#group'];\n    // If this element belongs to a group, but the group-holding element does\n    // not exist, we need to render it (at its original location).\n    if (!isset($element['#groups'][$group]['#group_exists'])) {\n      // Intentionally empty to clarify the flow; we simply return $element.\n    }\n    // If we injected this element into the group, then we want to render it.\n    elseif (!empty($element['#group_fieldset'])) {\n      // Intentionally empty to clarify the flow; we simply return $element.\n    }\n    // Otherwise, this element belongs to a group and the group exists, so we do\n    // not render it.\n    elseif (element_children($element['#groups'][$group])) {\n      $element['#printed'] = TRUE;\n    }\n  }\n\n  return $element;\n}\n\n/**\n * Creates a group formatted as vertical tabs.\n *\n * @param $element\n *   An associative array containing the properties and children of the\n *   fieldset.\n * @param $form_state\n *   The $form_state array for the form this vertical tab widget belongs to.\n * @return\n *   The processed element.\n */\nfunction form_process_vertical_tabs($element, &$form_state) {\n  // Inject a new fieldset as child, so that form_process_fieldset() processes\n  // this fieldset like any other fieldset.\n  $element['group'] = array(\n    '#type' => 'fieldset',\n    '#theme_wrappers' => array(),\n    '#parents' => $element['#parents'],\n  );\n\n  // The JavaScript stores the currently selected tab in this hidden\n  // field so that the active tab can be restored the next time the\n  // form is rendered, e.g. on preview pages or when form validation\n  // fails.\n  $name = implode('__', $element['#parents']);\n  if (isset($form_state['values'][$name . '__active_tab'])) {\n    $element['#default_tab'] = $form_state['values'][$name . '__active_tab'];\n  }\n  $element[$name . '__active_tab'] = array(\n    '#type' => 'hidden',\n    '#default_value' => $element['#default_tab'],\n    '#attributes' => array('class' => array('vertical-tabs-active-tab')),\n  );\n\n  return $element;\n}\n\n/**\n * Returns HTML for an element's children fieldsets as vertical tabs.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties and children of the\n *     fieldset. Properties used: #children.\n *\n * @ingroup themeable\n */\nfunction theme_vertical_tabs($variables) {\n  $element = $variables['element'];\n  // Add required JavaScript and Stylesheet.\n  drupal_add_library('system', 'vertical-tabs');\n\n  $output = '<h2 class=\"element-invisible\">' . t('Vertical Tabs') . '</h2>';\n  $output .= '<div class=\"vertical-tabs-panes\">' . $element['#children'] . '</div>';\n  return $output;\n}\n\n/**\n * Returns HTML for a submit button form element.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #attributes, #button_type, #name, #value.\n *\n * @ingroup themeable\n */\nfunction theme_submit($variables) {\n  return theme('button', $variables['element']);\n}\n\n/**\n * Returns HTML for a button form element.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #attributes, #button_type, #name, #value.\n *\n * @ingroup themeable\n */\nfunction theme_button($variables) {\n  $element = $variables['element'];\n  $element['#attributes']['type'] = 'submit';\n  element_set_attributes($element, array('id', 'name', 'value'));\n\n  $element['#attributes']['class'][] = 'form-' . $element['#button_type'];\n  if (!empty($element['#attributes']['disabled'])) {\n    $element['#attributes']['class'][] = 'form-button-disabled';\n  }\n\n  return '<input' . drupal_attributes($element['#attributes']) . ' />';\n}\n\n/**\n * Returns HTML for an image button form element.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #attributes, #button_type, #name, #value, #title, #src.\n *\n * @ingroup themeable\n */\nfunction theme_image_button($variables) {\n  $element = $variables['element'];\n  $element['#attributes']['type'] = 'image';\n  element_set_attributes($element, array('id', 'name', 'value'));\n\n  $element['#attributes']['src'] = file_create_url($element['#src']);\n  if (!empty($element['#title'])) {\n    $element['#attributes']['alt'] = $element['#title'];\n    $element['#attributes']['title'] = $element['#title'];\n  }\n\n  $element['#attributes']['class'][] = 'form-' . $element['#button_type'];\n  if (!empty($element['#attributes']['disabled'])) {\n    $element['#attributes']['class'][] = 'form-button-disabled';\n  }\n\n  return '<input' . drupal_attributes($element['#attributes']) . ' />';\n}\n\n/**\n * Returns HTML for a hidden form element.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #name, #value, #attributes.\n *\n * @ingroup themeable\n */\nfunction theme_hidden($variables) {\n  $element = $variables['element'];\n  $element['#attributes']['type'] = 'hidden';\n  element_set_attributes($element, array('name', 'value'));\n  return '<input' . drupal_attributes($element['#attributes']) . \" />\\n\";\n}\n\n/**\n * Returns HTML for a textfield form element.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #title, #value, #description, #size, #maxlength,\n *     #required, #attributes, #autocomplete_path.\n *\n * @ingroup themeable\n */\nfunction theme_textfield($variables) {\n  $element = $variables['element'];\n  $element['#attributes']['type'] = 'text';\n  element_set_attributes($element, array('id', 'name', 'value', 'size', 'maxlength'));\n  _form_set_class($element, array('form-text'));\n\n  $extra = '';\n  if ($element['#autocomplete_path'] && drupal_valid_path($element['#autocomplete_path'])) {\n    drupal_add_js('misc/autocomplete.js');\n    $element['#attributes']['class'][] = 'form-autocomplete';\n\n    $attributes = array();\n    $attributes['type'] = 'hidden';\n    $attributes['id'] = $element['#attributes']['id'] . '-autocomplete';\n    $attributes['value'] = url($element['#autocomplete_path'], array('absolute' => TRUE));\n    $attributes['disabled'] = 'disabled';\n    $attributes['class'][] = 'autocomplete';\n    $extra = '<input' . drupal_attributes($attributes) . ' />';\n  }\n\n  $output = '<input' . drupal_attributes($element['#attributes']) . ' />';\n\n  return $output . $extra;\n}\n\n/**\n * Returns HTML for a form.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #action, #method, #attributes, #children\n *\n * @ingroup themeable\n */\nfunction theme_form($variables) {\n  $element = $variables['element'];\n  if (isset($element['#action'])) {\n    $element['#attributes']['action'] = drupal_strip_dangerous_protocols($element['#action']);\n  }\n  element_set_attributes($element, array('method', 'id'));\n  if (empty($element['#attributes']['accept-charset'])) {\n    $element['#attributes']['accept-charset'] = \"UTF-8\";\n  }\n  // Anonymous DIV to satisfy XHTML compliance.\n  return '<form' . drupal_attributes($element['#attributes']) . '><div>' . $element['#children'] . '</div></form>';\n}\n\n/**\n * Returns HTML for a textarea form element.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #title, #value, #description, #rows, #cols, #required,\n *     #attributes\n *\n * @ingroup themeable\n */\nfunction theme_textarea($variables) {\n  $element = $variables['element'];\n  element_set_attributes($element, array('id', 'name', 'cols', 'rows'));\n  _form_set_class($element, array('form-textarea'));\n\n  $wrapper_attributes = array(\n    'class' => array('form-textarea-wrapper'),\n  );\n\n  // Add resizable behavior.\n  if (!empty($element['#resizable'])) {\n    drupal_add_js('misc/textarea.js');\n    $wrapper_attributes['class'][] = 'resizable';\n  }\n\n  $output = '<div' . drupal_attributes($wrapper_attributes) . '>';\n  $output .= '<textarea' . drupal_attributes($element['#attributes']) . '>' . check_plain($element['#value']) . '</textarea>';\n  $output .= '</div>';\n  return $output;\n}\n\n/**\n * Returns HTML for a password form element.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #title, #value, #description, #size, #maxlength,\n *     #required, #attributes.\n *\n * @ingroup themeable\n */\nfunction theme_password($variables) {\n  $element = $variables['element'];\n  $element['#attributes']['type'] = 'password';\n  element_set_attributes($element, array('id', 'name', 'value', 'size', 'maxlength'));\n  _form_set_class($element, array('form-text'));\n\n  return '<input' . drupal_attributes($element['#attributes']) . ' />';\n}\n\n/**\n * Expand weight elements into selects.\n */\nfunction form_process_weight($element) {\n  for ($n = (-1 * $element['#delta']); $n <= $element['#delta']; $n++) {\n    $weights[$n] = $n;\n  }\n  $element['#options'] = $weights;\n  $element['#type'] = 'select';\n  $element['#is_weight'] = TRUE;\n  $element += element_info('select');\n  return $element;\n}\n\n/**\n * Returns HTML for a file upload form element.\n *\n * For assistance with handling the uploaded file correctly, see the API\n * provided by file.inc.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #title, #name, #size, #description, #required,\n *     #attributes.\n *\n * @ingroup themeable\n */\nfunction theme_file($variables) {\n  $element = $variables['element'];\n  $element['#attributes']['type'] = 'file';\n  element_set_attributes($element, array('id', 'name', 'size'));\n  _form_set_class($element, array('form-file'));\n\n  return '<input' . drupal_attributes($element['#attributes']) . ' />';\n}\n\n/**\n * Returns HTML for a form element.\n *\n * Each form element is wrapped in a DIV container having the following CSS\n * classes:\n * - form-item: Generic for all form elements.\n * - form-type-#type: The internal element #type.\n * - form-item-#name: The internal form element #name (usually derived from the\n *   $form structure and set via form_builder()).\n * - form-disabled: Only set if the form element is #disabled.\n *\n * In addition to the element itself, the DIV contains a label for the element\n * based on the optional #title_display property, and an optional #description.\n *\n * The optional #title_display property can have these values:\n * - before: The label is output before the element. This is the default.\n *   The label includes the #title and the required marker, if #required.\n * - after: The label is output after the element. For example, this is used\n *   for radio and checkbox #type elements as set in system_element_info().\n *   If the #title is empty but the field is #required, the label will\n *   contain only the required marker.\n * - invisible: Labels are critical for screen readers to enable them to\n *   properly navigate through forms but can be visually distracting. This\n *   property hides the label for everyone except screen readers.\n * - attribute: Set the title attribute on the element to create a tooltip\n *   but output no label element. This is supported only for checkboxes\n *   and radios in form_pre_render_conditional_form_element(). It is used\n *   where a visual label is not needed, such as a table of checkboxes where\n *   the row and column provide the context. The tooltip will include the\n *   title and required marker.\n *\n * If the #title property is not set, then the label and any required marker\n * will not be output, regardless of the #title_display or #required values.\n * This can be useful in cases such as the password_confirm element, which\n * creates children elements that have their own labels and required markers,\n * but the parent element should have neither. Use this carefully because a\n * field without an associated label can cause accessibility challenges.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #title, #title_display, #description, #id, #required,\n *     #children, #type, #name.\n *\n * @ingroup themeable\n */\nfunction theme_form_element($variables) {\n  $element = &$variables['element'];\n  // This is also used in the installer, pre-database setup.\n  $t = get_t();\n\n  // This function is invoked as theme wrapper, but the rendered form element\n  // may not necessarily have been processed by form_builder().\n  $element += array(\n    '#title_display' => 'before',\n  );\n\n  // Add element #id for #type 'item'.\n  if (isset($element['#markup']) && !empty($element['#id'])) {\n    $attributes['id'] = $element['#id'];\n  }\n  // Add element's #type and #name as class to aid with JS/CSS selectors.\n  $attributes['class'] = array('form-item');\n  if (!empty($element['#type'])) {\n    $attributes['class'][] = 'form-type-' . strtr($element['#type'], '_', '-');\n  }\n  if (!empty($element['#name'])) {\n    $attributes['class'][] = 'form-item-' . strtr($element['#name'], array(' ' => '-', '_' => '-', '[' => '-', ']' => ''));\n  }\n  // Add a class for disabled elements to facilitate cross-browser styling.\n  if (!empty($element['#attributes']['disabled'])) {\n    $attributes['class'][] = 'form-disabled';\n  }\n  $output = '<div' . drupal_attributes($attributes) . '>' . \"\\n\";\n\n  // If #title is not set, we don't display any label or required marker.\n  if (!isset($element['#title'])) {\n    $element['#title_display'] = 'none';\n  }\n  $prefix = isset($element['#field_prefix']) ? '<span class=\"field-prefix\">' . $element['#field_prefix'] . '</span> ' : '';\n  $suffix = isset($element['#field_suffix']) ? ' <span class=\"field-suffix\">' . $element['#field_suffix'] . '</span>' : '';\n\n  switch ($element['#title_display']) {\n    case 'before':\n    case 'invisible':\n      $output .= ' ' . theme('form_element_label', $variables);\n      $output .= ' ' . $prefix . $element['#children'] . $suffix . \"\\n\";\n      break;\n\n    case 'after':\n      $output .= ' ' . $prefix . $element['#children'] . $suffix;\n      $output .= ' ' . theme('form_element_label', $variables) . \"\\n\";\n      break;\n\n    case 'none':\n    case 'attribute':\n      // Output no label and no required marker, only the children.\n      $output .= ' ' . $prefix . $element['#children'] . $suffix . \"\\n\";\n      break;\n  }\n\n  if (!empty($element['#description'])) {\n    $output .= '<div class=\"description\">' . $element['#description'] . \"</div>\\n\";\n  }\n\n  $output .= \"</div>\\n\";\n\n  return $output;\n}\n\n/**\n * Returns HTML for a marker for required form elements.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *\n * @ingroup themeable\n */\nfunction theme_form_required_marker($variables) {\n  // This is also used in the installer, pre-database setup.\n  $t = get_t();\n  $attributes = array(\n    'class' => 'form-required',\n    'title' => $t('This field is required.'),\n  );\n  return '<span' . drupal_attributes($attributes) . '>*</span>';\n}\n\n/**\n * Returns HTML for a form element label and required marker.\n *\n * Form element labels include the #title and a #required marker. The label is\n * associated with the element itself by the element #id. Labels may appear\n * before or after elements, depending on theme_form_element() and #title_display.\n *\n * This function will not be called for elements with no labels, depending on\n * #title_display. For elements that have an empty #title and are not required,\n * this function will output no label (''). For required elements that have an\n * empty #title, this will output the required marker alone within the label.\n * The label will use the #id to associate the marker with the field that is\n * required. That is especially important for screenreader users to know\n * which field is required.\n *\n * @param $variables\n *   An associative array containing:\n *   - element: An associative array containing the properties of the element.\n *     Properties used: #required, #title, #id, #value, #description.\n *\n * @ingroup themeable\n */\nfunction theme_form_element_label($variables) {\n  $element = $variables['element'];\n  // This is also used in the installer, pre-database setup.\n  $t = get_t();\n\n  // If title and required marker are both empty, output no label.\n  if (empty($element['#title']) && empty($element['#required'])) {\n    return '';\n  }\n\n  // If the element is required, a required marker is appended to the label.\n  $required = !empty($element['#required']) ? theme('form_required_marker', array('element' => $element)) : '';\n\n  $title = filter_xss_admin($element['#title']);\n\n  $attributes = array();\n  // Style the label as class option to display inline with the element.\n  if ($element['#title_display'] == 'after') {\n    $attributes['class'] = 'option';\n  }\n  // Show label only to screen readers to avoid disruption in visual flows.\n  elseif ($element['#title_display'] == 'invisible') {\n    $attributes['class'] = 'element-invisible';\n  }\n\n  if (!empty($element['#id'])) {\n    $attributes['for'] = $element['#id'];\n  }\n\n  // The leading whitespace helps visually separate fields from inline labels.\n  return ' <label' . drupal_attributes($attributes) . '>' . $t('!title !required', array('!title' => $title, '!required' => $required)) . \"</label>\\n\";\n}\n\n/**\n * Sets a form element's class attribute.\n *\n * Adds 'required' and 'error' classes as needed.\n *\n * @param &$element\n *   The form element.\n * @param $name\n *   Array of new class names to be added.\n */\nfunction _form_set_class(&$element, $class = array()) {\n  if (!empty($class)) {\n    if (!isset($element['#attributes']['class'])) {\n      $element['#attributes']['class'] = array();\n    }\n    $element['#attributes']['class'] = array_merge($element['#attributes']['class'], $class);\n  }\n  // This function is invoked from form element theme functions, but the\n  // rendered form element may not necessarily have been processed by\n  // form_builder().\n  if (!empty($element['#required'])) {\n    $element['#attributes']['class'][] = 'required';\n  }\n  if (isset($element['#parents']) && form_get_error($element)) {\n    $element['#attributes']['class'][] = 'error';\n  }\n}\n\n/**\n * @} End of \"defgroup form_api\".\n */\n\n/**\n * @defgroup batch Batch operations\n * @{\n * Functions allowing forms processing to be spread out over several page\n * requests, thus ensuring that the processing does not get interrupted\n * because of a PHP timeout, while allowing the user to receive feedback\n * on the progress of the ongoing operations.\n *\n * The API is primarily designed to integrate nicely with the Form API\n * workflow, but can also be used by non-Form API scripts (like update.php)\n * or even simple page callbacks (which should probably be used sparingly).\n *\n * Example:\n * @code\n * $batch = array(\n *   'title' => t('Exporting'),\n *   'operations' => array(\n *     array('my_function_1', array($account->uid, 'story')),\n *     array('my_function_2', array()),\n *   ),\n *   'finished' => 'my_finished_callback',\n *   'file' => 'path_to_file_containing_myfunctions',\n * );\n * batch_set($batch);\n * // only needed if not inside a form _submit handler :\n * batch_process();\n * @endcode\n *\n * Note: if the batch 'title', 'init_message', 'progress_message', or\n * 'error_message' could contain any user input, it is the responsibility of\n * the code calling batch_set() to sanitize them first with a function like\n * check_plain() or filter_xss().\n *\n * Sample batch operations:\n * @code\n * // Simple and artificial: load a node of a given type for a given user\n * function my_function_1($uid, $type, &$context) {\n *   // The $context array gathers batch context information about the execution (read),\n *   // as well as 'return values' for the current operation (write)\n *   // The following keys are provided :\n *   // 'results' (read / write): The array of results gathered so far by\n *   //   the batch processing, for the current operation to append its own.\n *   // 'message' (write): A text message displayed in the progress page.\n *   // The following keys allow for multi-step operations :\n *   // 'sandbox' (read / write): An array that can be freely used to\n *   //   store persistent data between iterations. It is recommended to\n *   //   use this instead of $_SESSION, which is unsafe if the user\n *   //   continues browsing in a separate window while the batch is processing.\n *   // 'finished' (write): A float number between 0 and 1 informing\n *   //   the processing engine of the completion level for the operation.\n *   //   1 (or no value explicitly set) means the operation is finished\n *   //   and the batch processing can continue to the next operation.\n *\n *   $node = node_load(array('uid' => $uid, 'type' => $type));\n *   $context['results'][] = $node->nid . ' : ' . $node->title;\n *   $context['message'] = $node->title;\n * }\n *\n * // More advanced example: multi-step operation - load all nodes, five by five\n * function my_function_2(&$context) {\n *   if (empty($context['sandbox'])) {\n *     $context['sandbox']['progress'] = 0;\n *     $context['sandbox']['current_node'] = 0;\n *     $context['sandbox']['max'] = db_query('SELECT COUNT(DISTINCT nid) FROM {node}')->fetchField();\n *   }\n *   $limit = 5;\n *   $result = db_select('node')\n *     ->fields('node', array('nid'))\n *     ->condition('nid', $context['sandbox']['current_node'], '>')\n *     ->orderBy('nid')\n *     ->range(0, $limit)\n *     ->execute();\n *   foreach ($result as $row) {\n *     $node = node_load($row->nid, NULL, TRUE);\n *     $context['results'][] = $node->nid . ' : ' . $node->title;\n *     $context['sandbox']['progress']++;\n *     $context['sandbox']['current_node'] = $node->nid;\n *     $context['message'] = $node->title;\n *   }\n *   if ($context['sandbox']['progress'] != $context['sandbox']['max']) {\n *     $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];\n *   }\n * }\n * @endcode\n *\n * Sample 'finished' callback:\n * @code\n * function batch_test_finished($success, $results, $operations) {\n *   if ($success) {\n *     $message = format_plural(count($results), 'One post processed.', '@count posts processed.');\n *   }\n *   else {\n *     $message = t('Finished with an error.');\n *   }\n *   drupal_set_message($message);\n *   // Providing data for the redirected page is done through $_SESSION.\n *   foreach ($results as $result) {\n *     $items[] = t('Loaded node %title.', array('%title' => $result));\n *   }\n *   $_SESSION['my_batch_results'] = $items;\n * }\n * @endcode\n */\n\n/**\n * Opens a new batch.\n *\n * @param $batch\n *   An array defining the batch. The following keys can be used -- only\n *   'operations' is required, and batch_init() provides default values for\n *   the messages.\n *   - 'operations': Array of function calls to be performed.\n *     Example:\n *     @code\n *     array(\n *       array('my_function_1', array($arg1)),\n *       array('my_function_2', array($arg2_1, $arg2_2)),\n *     )\n *     @endcode\n *   - 'title': Title for the progress page. Only safe strings should be passed.\n *     Defaults to t('Processing').\n *   - 'init_message': Message displayed while the processing is initialized.\n *     Defaults to t('Initializing.').\n *   - 'progress_message': Message displayed while processing the batch.\n *     Available placeholders are @current, @remaining, @total, @percentage,\n *     @estimate and @elapsed. Defaults to t('Completed @current of @total.').\n *   - 'error_message': Message displayed if an error occurred while processing\n *     the batch. Defaults to t('An error has occurred.').\n *   - 'finished': Name of a function to be executed after the batch has\n *     completed. This should be used to perform any result massaging that\n *     may be needed, and possibly save data in $_SESSION for display after\n *     final page redirection.\n *   - 'file': Path to the file containing the definitions of the\n *     'operations' and 'finished' functions, for instance if they don't\n *     reside in the main .module file. The path should be relative to\n *     base_path(), and thus should be built using drupal_get_path().\n *   - 'css': Array of paths to CSS files to be used on the progress page.\n *   - 'url_options': options passed to url() when constructing redirect\n *     URLs for the batch.\n *\n * Operations are added as new batch sets. Batch sets are used to ensure\n * clean code independence, ensuring that several batches submitted by\n * different parts of the code (core / contrib modules) can be processed\n * correctly while not interfering or having to cope with each other. Each\n * batch set gets to specify his own UI messages, operates on its own set\n * of operations and results, and triggers its own 'finished' callback.\n * Batch sets are processed sequentially, with the progress bar starting\n * fresh for every new set.\n */\nfunction batch_set($batch_definition) {\n  if ($batch_definition) {\n    $batch =& batch_get();\n\n    // Initialize the batch if needed.\n    if (empty($batch)) {\n      $batch = array(\n        'sets' => array(),\n        'has_form_submits' => FALSE,\n      );\n    }\n\n    // Base and default properties for the batch set.\n    // Use get_t() to allow batches at install time.\n    $t = get_t();\n    $init = array(\n      'sandbox' => array(),\n      'results' => array(),\n      'success' => FALSE,\n      'start' => 0,\n      'elapsed' => 0,\n    );\n    $defaults = array(\n      'title' => $t('Processing'),\n      'init_message' => $t('Initializing.'),\n      'progress_message' => $t('Completed @current of @total.'),\n      'error_message' => $t('An error has occurred.'),\n      'css' => array(),\n    );\n    $batch_set = $init + $batch_definition + $defaults;\n\n    // Tweak init_message to avoid the bottom of the page flickering down after\n    // init phase.\n    $batch_set['init_message'] .= '<br/>&nbsp;';\n\n    // The non-concurrent workflow of batch execution allows us to save\n    // numberOfItems() queries by handling our own counter.\n    $batch_set['total'] = count($batch_set['operations']);\n    $batch_set['count'] = $batch_set['total'];\n\n    // Add the set to the batch.\n    if (empty($batch['id'])) {\n      // The batch is not running yet. Simply add the new set.\n      $batch['sets'][] = $batch_set;\n    }\n    else {\n      // The set is being added while the batch is running. Insert the new set\n      // right after the current one to ensure execution order, and store its\n      // operations in a queue.\n      $index = $batch['current_set'] + 1;\n      $slice1 = array_slice($batch['sets'], 0, $index);\n      $slice2 = array_slice($batch['sets'], $index);\n      $batch['sets'] = array_merge($slice1, array($batch_set), $slice2);\n      _batch_populate_queue($batch, $index);\n    }\n  }\n}\n\n/**\n * Processes the batch.\n *\n * Unless the batch has been marked with 'progressive' = FALSE, the function\n * issues a drupal_goto and thus ends page execution.\n *\n * This function is generally not needed in form submit handlers;\n * Form API takes care of batches that were set during form submission.\n *\n * @param $redirect\n *   (optional) Path to redirect to when the batch has finished processing.\n * @param $url\n *   (optional - should only be used for separate scripts like update.php)\n *   URL of the batch processing page.\n * @param $redirect_callback\n *   (optional) Specify a function to be called to redirect to the progressive\n *   processing page. By default drupal_goto() will be used to redirect to a\n *   page which will do the progressive page. Specifying another function will\n *   allow the progressive processing to be processed differently.\n */\nfunction batch_process($redirect = NULL, $url = 'batch', $redirect_callback = 'drupal_goto') {\n  $batch =& batch_get();\n\n  drupal_theme_initialize();\n\n  if (isset($batch)) {\n    // Add process information\n    $process_info = array(\n      'current_set' => 0,\n      'progressive' => TRUE,\n      'url' => $url,\n      'url_options' => array(),\n      'source_url' => $_GET['q'],\n      'redirect' => $redirect,\n      'theme' => $GLOBALS['theme_key'],\n      'redirect_callback' => $redirect_callback,\n    );\n    $batch += $process_info;\n\n    // The batch is now completely built. Allow other modules to make changes\n    // to the batch so that it is easier to reuse batch processes in other\n    // environments.\n    drupal_alter('batch', $batch);\n\n    // Assign an arbitrary id: don't rely on a serial column in the 'batch'\n    // table, since non-progressive batches skip database storage completely.\n    $batch['id'] = db_next_id();\n\n    // Move operations to a job queue. Non-progressive batches will use a\n    // memory-based queue.\n    foreach ($batch['sets'] as $key => $batch_set) {\n      _batch_populate_queue($batch, $key);\n    }\n\n    // Initiate processing.\n    if ($batch['progressive']) {\n      // Now that we have a batch id, we can generate the redirection link in\n      // the generic error message.\n      $t = get_t();\n      $batch['error_message'] = $t('Please continue to <a href=\"@error_url\">the error page</a>', array('@error_url' => url($url, array('query' => array('id' => $batch['id'], 'op' => 'finished')))));\n\n      // Clear the way for the drupal_goto() redirection to the batch processing\n      // page, by saving and unsetting the 'destination', if there is any.\n      if (isset($_GET['destination'])) {\n        $batch['destination'] = $_GET['destination'];\n        unset($_GET['destination']);\n      }\n\n      // Store the batch.\n      db_insert('batch')\n        ->fields(array(\n          'bid' => $batch['id'],\n          'timestamp' => REQUEST_TIME,\n          'token' => drupal_get_token($batch['id']),\n          'batch' => serialize($batch),\n        ))\n        ->execute();\n\n      // Set the batch number in the session to guarantee that it will stay alive.\n      $_SESSION['batches'][$batch['id']] = TRUE;\n\n      // Redirect for processing.\n      $function = $batch['redirect_callback'];\n      if (function_exists($function)) {\n        $function($batch['url'], array('query' => array('op' => 'start', 'id' => $batch['id'])));\n      }\n    }\n    else {\n      // Non-progressive execution: bypass the whole progressbar workflow\n      // and execute the batch in one pass.\n      require_once DRUPAL_ROOT . '/includes/batch.inc';\n      _batch_process();\n    }\n  }\n}\n\n/**\n * Retrieves the current batch.\n */\nfunction &batch_get() {\n  // Not drupal_static(), because Batch API operates at a lower level than most\n  // use-cases for resetting static variables, and we specifically do not want a\n  // global drupal_static_reset() resetting the batch information. Functions\n  // that are part of the Batch API and need to reset the batch information may\n  // call batch_get() and manipulate the result by reference. Functions that are\n  // not part of the Batch API can also do this, but shouldn't.\n  static $batch = array();\n  return $batch;\n}\n\n/**\n * Populates a job queue with the operations of a batch set.\n *\n * Depending on whether the batch is progressive or not, the BatchQueue or\n * BatchMemoryQueue handler classes will be used.\n *\n * @param $batch\n *   The batch array.\n * @param $set_id\n *   The id of the set to process.\n * @return\n *   The name and class of the queue are added by reference to the batch set.\n */\nfunction _batch_populate_queue(&$batch, $set_id) {\n  $batch_set = &$batch['sets'][$set_id];\n\n  if (isset($batch_set['operations'])) {\n    $batch_set += array(\n      'queue' => array(\n        'name' => 'drupal_batch:' . $batch['id'] . ':' . $set_id,\n        'class' => $batch['progressive'] ? 'BatchQueue' : 'BatchMemoryQueue',\n      ),\n    );\n\n    $queue = _batch_queue($batch_set);\n    $queue->createQueue();\n    foreach ($batch_set['operations'] as $operation) {\n      $queue->createItem($operation);\n    }\n\n    unset($batch_set['operations']);\n  }\n}\n\n/**\n * Returns a queue object for a batch set.\n *\n * @param $batch_set\n *   The batch set.\n * @return\n *   The queue object.\n */\nfunction _batch_queue($batch_set) {\n  static $queues;\n\n  // The class autoloader is not available when running update.php, so make\n  // sure the files are manually included.\n  if (!isset($queues)) {\n    $queues = array();\n    require_once DRUPAL_ROOT . '/modules/system/system.queue.inc';\n    require_once DRUPAL_ROOT . '/includes/batch.queue.inc';\n  }\n\n  if (isset($batch_set['queue'])) {\n    $name = $batch_set['queue']['name'];\n    $class = $batch_set['queue']['class'];\n\n    if (!isset($queues[$class][$name])) {\n      $queues[$class][$name] = new $class($name);\n    }\n    return $queues[$class][$name];\n  }\n}\n\n/**\n * @} End of \"defgroup batch\".\n */",
  "language": "PHP"
}